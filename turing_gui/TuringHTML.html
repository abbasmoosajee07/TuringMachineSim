<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Turing Machine Simulator</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
    <!-- Ace Editor CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.6/ace.min.css">
    <style>
        /* === ROOT VARIABLES === */
        :root {
            --primary-color: #fd0d8d;
            --primary-hover: #f381cf;

            --reset-bg: #cf5e45;
            --load-bg: #019875;
            --copy-bg: #0778c4;
            --clear-bg: #c0392b;
            --goto-bg: #4bf542;
            --step-bg: #5a4cd1;
            --run-bg: #00b0ae;
            --pause-bg: #ffdd48;
            --upload-bg: #f308eb;

            --hover-brightness: 1.2;
            --active-brightness: 0.8;
        }

        /* === INPUT STYLING === */
        input:focus,
        input:hover {
            outline: none !important;
            box-shadow: none !important;
        }

        input.form-control:focus {
            outline: none;
            border-color: var(--primary-hover);
            border-width: 1px;
        }

        /* === BODY BASE STYLES === */
        body {
            background-color: #f5f5f5;
            font-size: 0.9rem;
        }

        /* === SLIDER (WebKit Browsers) === */
        .slider-primary::-webkit-slider-thumb {
            background-color: var(--primary-color);
            border: none;
            border-radius: 50%;
            height: 16px;
            width: 16px;
            margin-top: -6px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .slider-primary:hover::-webkit-slider-thumb {
            background-color: var(--primary-hover);
            transform: scale(1.05);
        }

        .slider-primary::-webkit-slider-runnable-track {
            background-color: #ddd;
            height: 6px;
            border-radius: 3px;
        }

        /* === TYPOGRAPHY === */
        .stepState {
            font-size: 1.15rem;
            font-weight: 300;
            letter-spacing: 0.35px;
            margin-top: 0.5rem;
        }

        .monospace,
        .rules-info,
        .step-state {
            font-family: monospace;
            font-size: 0.9rem;
        }

        /* === CARD STYLES === */
        .card {
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .card-header {
            font-weight: bold;
            font-size: 1.05rem;
            background-color: #f9f9f9;
            color: #333;
            padding: 0.4rem 0.8rem;
            border-bottom: 1px solid #dee2e6;
            letter-spacing: 0.5px;
        }

        /* === TAPE STYLES === */
        .tape-wrapper {
            width: 100%;
            overflow-x: auto;
            padding: 10px 0;
            margin: 10px 0;
            background-color: #f9f9f9;
            border-radius: 2px;
            border: 1pt solid #ccc;
            scrollbar-width: thin;
            scrollbar-color: #888 #f1f1f1;
        }

        .tape-container {
            display: inline-flex;
            min-width: 100%;
        }

        .tape-cell {
            min-width: 40px;
            width: 40px;
            height: 40px;
            border: 1px solid #ddd;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 2px;
            font-size: 21px;
            background-color: white;
            flex-shrink: 0;
            font-weight: 600; /* <- make all text bold */
        }

        .tape-cell.active {
            border: 4px solid var(--primary-color);
            font-weight: bold;
        }

        .tape-current {
            color: var(--primary-color);
            font-weight: bold;
        }

        /* === SCROLLBAR STYLING === */
        .tape-container::-webkit-scrollbar{
            height: 8px;
        }

        .tape-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        .tape-container::-webkit-scrollbar-thumb{
            background: #888;
            border-radius: 4px;
        }

        .tape-container::-webkit-scrollbar-thumb:hover{
            background: #555;
        }

        /* === RULES TEXTAREA === */
        #rulesEditor {
            height: 200px;
            width: 100%;
            border: 1px solid #dee2e6;
            border-radius: 0.25rem;
        }
        .ace_gutter {
            background-color: #f8f9fa !important;
            color: #6c757d !important;
        }

        .monospace {
            font-family: monospace;
            white-space: pre-wrap;
            word-break: break-word;
        }

        /* === STATE INDICATORS === */
        .step-state {
            font-size: 1.1rem;
        }

        .step-index {
            color: var(--primary-color);
        }

        .machineStatus {
            transition: all 0.3s ease;
            font-size: 1.5rem !important;
        }

        /* === BUTTON GROUP === */
        .btn-group {
            margin-top: 15px;
        }


        /* === BUTTON ICON SPACING === */
        .btn i {
            margin-right: 5px;
        }

        /* === CONTROL BUTTON === */
        .control-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            font-size: 1.75rem;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            transform: scale(1.15);
        }

        /* === BUTTON BASE === */
        .btn {
            display: inline-block;
            vertical-align: middle;
            text-align: center;
            font-weight: 550;
            color: black !important;
            transition: filter 0.2s ease, background-color 0.2s ease;
            color: black !important;
            transition: filter 0.2s ease, background-color 0.2s ease;
            user-select: none;

            white-space: normal !important;
            word-break: break-word;
        }

        /* === BUTTON VARIANTS === */
        .btn-reset  { background-color: var(--reset-bg) !important; }
        .btn-load   { background-color: var(--load-bg) !important; }
        .btn-copy   { background-color: var(--copy-bg) !important; }
        .btn-clear  { background-color: var(--clear-bg) !important; }
        .btn-goto   { background-color: var(--goto-bg) !important; }
        .btn-step   { background-color: var(--step-bg) !important; }
        .btn-run    { background-color: var(--run-bg) !important; }
        .btn-pause  { background-color: var(--pause-bg) !important; }
        .btn-upload  { background-color: var(--upload-bg) !important; }


        /* === BUTTON INTERACTIONS === */
        .btn:hover,
        .btn:focus,
        .btn:focus-visible,
        .info-btn {
            filter: brightness(var(--hover-brightness)) !important;
            transform: scale(1.05);
        }

        .btn:active,
        .info-btn {
            filter: brightness(var(--active-brightness)) !important;
            border: none !important;
        }

        /* === DISABLED BUTTON STATE === */
        button:disabled,
        .btn:disabled {
            background-color: #e0e0e0 !important;
            color: #888 !important;
            border-color: #ccc !important;
            cursor: not-allowed !important;
            opacity: 1 !important;
            filter: none !important;
        }
    </style>
</head>

<body>
    <!-- Control button -->
    <button id="ControlBtn" class="control-btn bi bi-play-fill">Run</button>


    <!-- Main GUI-->
    <div class="container mt-4">
        <h1 class="text-center mb-4">Turing Machine Simulator</h1>

        <!-- Tape Display -->
        <div class="card">
            <div class="card-header">Ticker Tape</div>
            <div class="card-body">
                <!-- Tape Display -->
                <div class="mb-4">
                    <div class="tape-wrapper border rounded p-2 bg-light">
                        <div id="tapeDisplay" class="tape-container"></div>
                    </div>
                </div>

                <!-- Machine Status -->
                <div class="mb-2">
                    <div id="machineStatus" class="text-machineStatus fw-bold text-center"></div>
                </div>

                <!-- History Slider and Step Info -->
                <div class="mb-4">
                    <label for="historySlider" class="form-label fw-semibold">Step History:</label>
                    <input type="range" class="form-range slider-primary" id="historySlider" min="0" max="0" value="0">
                </div>

                <div id="stepState" class="step-state text-center small text-muted"></div>
            </div>
        </div>

        <!-- Controls and Configuration -->
        <div class="row mt-3 align-items-stretch"> <!-- 🔧 align items vertically -->

            <!-- Configure Model -->
            <div class="col-md-8 mb-2">
                <div class="card h-100">
                    <div class="card-header">Configure Model</div>
                    <div class="card-body">

                        <!-- Transition Rules -->
                        <div class="mb-3 flex-grow-1">
                            <label for="rulesEditor" class="form-label">Transition Rules:</label>
                            <div id="rulesEditor" class="form-control h-100" style="min-height: 200px; white-space: pre-wrap;">INIT | FIND | R
FIND | FIND | R
FIND _ HALT | R</div>
                        </div>

                        <!-- Initial Tape -->
                        <div class="mb-3">
                            <label for="tapeInput" class="form-label">Initial Tape:</label>
                            <input type="text" id="tapeInput" class="form-control" value="|||||||">
                        </div>

                        <!-- Action Buttons -->
                        <div class="row g-2 mt-auto"> <!-- 🔧 push to bottom -->
                            <div class="col-3">
                                <button id="clearRulesBtn" class="btn btn-clear w-100 action-btn bi bi-trash-fill"> Clear</button>
                            </div>
                            <div class="col-3">
                                <input type="file" id="fileInput" accept=".txt" style="display: none;">
                                <button id="uploadBtn" class="btn btn-upload w-100 action-btn bi bi-file-earmark-arrow-up"> Upload</button>
                            </div>
                            <div class="col-3">
                                <button id="copyRulesBtn" class="btn btn-copy w-100 action-btn bi bi-clipboard-fill"> Copy</button>
                            </div>
                            <div class="col-3">
                                <button id="loadBtn" class="btn btn-load w-100 action-btn bi bi-upload"> Load</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Control Machine -->
            <div class="col-md-4 mb-2">
                <div class="card h-100">
                    <div class="card-header">Control Machine</div>
                    <div class="card-body d-flex flex-column"> <!-- 🔧 flex column -->

                        <!-- Step Navigation -->
                        <div class="mb-3">
                            <div class="row align-items-center g-2">
                                <div class="col-4">
                                    <label for="gotoStep" class="form-label mb-0 w-100">Seek Step:</label>
                                </div>
                                <div class="col-4">
                                    <input type="number" id="gotoStep" class="form-control" min="0" title="Seek specific step in history">
                                </div>
                                <div class="col-4">
                                    <button class="btn btn-goto w-100 action-btn bi bi-signpost-fill" id="gotoBtn">Seek</button>
                                </div>
                            </div>
                        </div>

                        <!-- Configuration Options -->
                        <div class="mb-3">
                            <label for="stepEntry" class="form-label">Jump Steps:</label>
                            <input type="number" id="stepEntry" class="form-control" value="1" min="1" title="Steps per jump">
                        </div>

                        <div class="mb-3">
                            <label for="maxSteps" class="form-label">Max Steps:</label>
                            <input type="number" id="maxSteps" class="form-control" value="1000000" min="1" title="Max steps">
                        </div>

                        <div class="mb-3">
                            <label for="delayEntry" class="form-label">Speed (ms):</label>
                            <input type="number" id="delayEntry" class="form-control" value="300" min="1" title="Step delay (ms)">
                        </div>

                        <!-- Control Buttons -->
                        <div class="row mb-3 g-2 mt-auto"> <!-- 🔧 align bottom -->
                            <div class="col-4">
                                <button id="stepBtn" class="btn btn-step w-100 action-btn bi bi-forward-fill">Jump</button>
                            </div>
                            <div class="col-4">
                                <button id="RunPauseBtn" class="btn btn-runpause w-100 action-btn bi bi-play-fill">Play</button>
                            </div>
                            <div class="col-4">
                                <button id="resetBtn" class="btn btn-reset w-100 action-btn bi bi-arrow-clockwise">Reset</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>


        <!-- Model Results -->
        <div class="card mt-3">
            <div class="card-header">Model Results</div>
            <div class="card-body">
                <div id="results" class="monospace"></div>
                <div id="resources" class="monospace mt-2"></div>
            </div>
        </div>

        <!-- Help Card -->
        <div class="card mt-3" id="helpCard">
        <div class="card-header">
            🧠 Turing Machine Help
        </div>
        <div class="card-body">
            <h5 class="card-title">Simulator Overview</h5>
            <p class="card-text">
            This simulator visualizes the execution of a deterministic Turing Machine.
            You can define custom rules, input tape values, and run the machine step-by-step or continuously.
            </p>

            <h5>📘 TRANSITION RULE FORMAT</h5>
            <pre class="bg-light p-2 rounded"><code>currentState currentSymbol newState newSymbol moveDirection
        Example: INIT 0 INIT 0 R</code></pre>

            <h6>🔧 BASIC SETUP</h6>
            <ul class="small">
            <li>Blank Symbol: '<span id="blankSymbolPlaceholder"></span>'</li>
            <li>Initial State: '<span id="initStatePlaceholder"></span>'</li>
            <li>Halt State: '<span id="haltStatePlaceholder"></span>'</li>
            <li>Move Directions: 'L' (left) | 'R' (right)</li>
            </ul>

            <h6>🚦 MACHINE LIMITS</h6>
            <ul class="small">
            <li>MAX STATES: <span id="maxStatesPlaceholder"></span></li>
            <li>MAX TAPE LEN: <span id="maxTapeLenPlaceholder"></span></li>
            <li>MAX STATE SIZE: <span id="maxStateSizePlaceholder"></span> characters</li>
            <li>TRANSITION SIZE: <span id="transitionSizePlaceholder"></span> rules</li>
            </ul>
        </div>
        </div>

        <!-- Advanced Settings Card -->
        <div class="card mt-3">
            <div class="card-header advanced-header" id="advancedHeader">
                ⚙️ Advanced Settings
            </div>
            <div class="card-body advanced-content hidden" id="advancedContent">
                <div class="row">
                    <div class="col-md-6">
                        <div class="mb-3">
                            <label for="maxStatesInput" class="form-label">MAX STATES:</label>
                            <input type="number" id="maxStatesInput" class="form-control" min="1" value="1024">
                        </div>
                        <div class="mb-3">
                            <label for="maxTapeLenInput" class="form-label">MAX TAPE LENGTH:</label>
                            <input type="number" id="maxTapeLenInput" class="form-control" min="1" value="1048576">
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="mb-3">
                            <label for="maxStateSizeInput" class="form-label">MAX STATE SIZE (chars):</label>
                            <input type="number" id="maxStateSizeInput" class="form-control" min="1" value="32">
                        </div>
                        <div class="mb-3">
                            <label for="transitionSizeInput" class="form-label">MAX TRANSITIONS:</label>
                            <input type="number" id="transitionSizeInput" class="form-control" min="1" value="710000">
                        </div>
                    </div>
                </div>
                <div class="row">
                    <div class="col-6">
                        <button id="saveAdvancedBtn" class="btn btn-primary w-100">Save Settings</button>
                    </div>
                    <div class="col-6">
                        <button id="resetAdvancedBtn" class="btn btn-secondary w-100">Reset Defaults</button>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <footer class="text-center py-3 mt-4 bg-light border-top">
        <a href="https://github.com/abbasmoosajee07/TuringMachineSim" target="_blank"
            title="View on GitHub" class="text-dark">
            <i class="bi bi-github h4"></i>
        </a>
    </footer>

    <!-- JavaScript Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.6/ace.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.6/ext-language_tools.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Main Application Script -->
    <script type="module">
        // Initialize Ace Editor
        const editor = ace.edit("rulesEditor");
        editor.setTheme("ace/theme/chrome");
        editor.session.setMode("ace/mode/text");
        editor.setOptions({
            fontSize: "14px",
            showLineNumbers: true,
            showGutter: true,
            highlightActiveLine: true,
            enableBasicAutocompletion: true,
            enableLiveAutocompletion: true
        });

        // Make editor available globally
        window.getRulesText = () => editor.getValue();
        window.setRulesText = (text) => editor.setValue(text);

        class TuringConfig {
            static LEFT = "L";
            static RIGHT = "R";
            static BLANK = "_";

            static INIT_STATE = "INIT";
            static HALT_STATE = "HALT";
            static COMMENT_PREFIX = "//";

            static MAX_STATES = 1024;
            static MAX_TAPE_LEN = 1048576;
            static MAX_STATE_SIZE = 32;
            static TRANSITION_SIZE = 710000;

            static getTimestamp() {
                return performance.now() / 1000;
            }

            static getCurrentMemoryMB() {
                return performance.memory ? (performance.memory.usedJSHeapSize / (1024 * 1024)).toFixed(2) : 'N/A';
            }

            parseTransitionRules(transitionRulesStr) {
                const transitionsList = [];
                const rawRuleList = transitionRulesStr.split("\n");
                for (const rawLine of rawRuleList) {
                    const line = rawLine.trim();
                    if (!line || line.startsWith("//")) continue;
                    const cleanedLine = line.split("//")[0].trim();
                    const values = cleanedLine.split(/\s+/).filter(val => val.trim());

                    if (values.length !== 5) {
                        throw new Error(`Invalid transition: "${cleanedLine}". Expected 5 elements, got ${values.length}`);
                    }

                    const [currentState, currentSymbol, newState, newSymbol, direction] = values;
                    if (direction !== "L" && direction !== "R") {
                        throw new Error(`Invalid move direction: '${direction}' in line "${cleanedLine}". Must be 'L' or 'R'.`);
                    }

                    for (const [symbol, label] of [[currentSymbol, "current"], [newSymbol, "new"]]) {
                        if (symbol.length !== 1) {
                            throw new Error(`Invalid ${label}_symbol '${symbol}'. Must be a single character.`);
                        }
                    }

                    transitionsList.push([currentState, currentSymbol, newState, newSymbol, direction]);
                }

                if (transitionsList.length === 0) {
                    throw new Error("No valid transition rules found.");
                }

                return transitionsList;
            }
        }

        class MachineLogic {
            constructor(
                transitionsList,
                initState = TuringConfig.INIT_STATE,
                haltState = TuringConfig.HALT_STATE,
                blankSymbol = TuringConfig.BLANK) {
                this.init_state = initState;
                this.halt_state = haltState;
                this.blank_symbol = blankSymbol;

                this.MAX_STATES = TuringConfig.MAX_STATES;
                this.MAX_STATE_SIZE = TuringConfig.MAX_STATE_SIZE;

                this.transitions_list = transitionsList;
                this.transitions_dict = this._buildTransitionDict(transitionsList, initState, haltState);

                // Initialize Tape
                this.head_position = 0;
                this.current_state = initState;
                this.tape = {};
                this.running = true;
                this.input_tape = "";
            }

            _validateTransition(transition) {
                if (transition.length !== 5) {
                    throw new Error(`Invalid transition: ${transition}. Expected 5 elements: (currentState, currentSymbol, newState, newSymbol, moveDirection).`);
                }

                const [current_state, current_symbol, new_state, new_symbol, direction] = transition;

                if (direction !== TuringConfig.LEFT && direction !== TuringConfig.RIGHT) {
                    throw new Error(`Invalid move direction: '${direction}'. Must be 'L' or 'R'.`);
                }

                for (const [symbol, label] of [[current_symbol, "current"], [new_symbol, "new"]]) {
                    if (symbol.length !== 1) {
                        throw new Error(`Invalid ${label}_symbol: '${symbol}'. Must be a single character.`);
                    }
                }

                for (const [state, label] of [[current_state, "current"], [new_state, "new"]]) {
                    if (state.length > this.MAX_STATE_SIZE) {
                        throw new Error(`Invalid ${label}_state: ${state} size=${state.length}. State Size must be less than ${this.MAX_STATE_SIZE} characters.`);
                    }
                }

                return transition;
            }

            _buildTransitionDict(transitionsList, initState, haltState) {
                const transitionDict = {};
                let hasHaltState = false;

                for (const transition of transitionsList) {
                    const [currentState, currentSymbol, newState, newSymbol, moveDirection] = this._validateTransition(transition);

                    if (!transitionDict[currentState]) {
                        transitionDict[currentState] = {};
                    }

                    if (currentSymbol in transitionDict[currentState]) {
                        throw new Error(`Duplicate transition for state ${currentState} and symbol ${currentSymbol}`);
                    }

                    transitionDict[currentState][currentSymbol] = [newState, newSymbol, moveDirection];

                    if (newState === haltState) {
                        hasHaltState = true;
                    }
                }

                if (Object.keys(transitionDict).length > this.MAX_STATES) {
                    throw new Error(`Too many states: ${Object.keys(transitionDict).length}. Maximum is ${this.MAX_STATES}.`);
                }

                if (!transitionDict[initState]) {
                    throw new Error(`Initial state ${initState} not found in the transitions`);
                }

                if (!hasHaltState) {
                    throw new Error(`Halt state ${haltState} not found in the transitions`);
                }

                return transitionDict;
            }

            _setTape(inputTape) {
                if (inputTape.includes(" ")) {
                    throw new Error("Input tape must not contain spaces");
                }

                this.head_position = 0;
                this.current_state = this.init_state;
                this.tape = {};
                this.input_tape = inputTape;

                for (let i = 0; i < inputTape.length; i++) {
                    const symbol = inputTape[i];
                    if (symbol !== this.blank_symbol) {
                        this.tape[i] = symbol;
                    }
                }
            }

            _getTapeBoundaries(windowSize = 5) {
                const positions = Object.keys(this.tape).map(Number);
                let minPos = positions.length > 0 ? Math.min(...positions) : this.head_position - windowSize;
                let maxPos = positions.length > 0 ? Math.max(...positions) : this.head_position + windowSize;

                minPos = Math.min(minPos, this.head_position) - windowSize;
                maxPos = Math.max(maxPos, this.head_position) + windowSize;
                return [minPos, maxPos];
            }

            _printTapeState(visualize = true) {
                const [minPos, maxPos] = this._getTapeBoundaries();
                const headPosInWindow = this.head_position - minPos;

                let tapeStr = "";
                for (let i = minPos; i <= maxPos; i++) {
                    tapeStr += this.tape[i] ?? this.blank_symbol;
                }

                const pointerStr = `${" ".repeat(headPosInWindow)}^`;
                const tape_state = `[${this.stepCount}]: ${this.current_state}`
                const printedState = [tapeStr, pointerStr, tape_state, ""];

                if (visualize) {
                    console.log(printedState.join("\n"));
                }

                return tapeStr.replace(new RegExp(`^${this.blank_symbol}+|${this.blank_symbol}+$`, 'g'), '');
            }

            _stepLogic() {
                const stateTransitions = this.transitions_dict[this.current_state];
                if (!stateTransitions) {
                    throw new Error(`No transitions for state ${this.current_state} with input tape ${this.input_tape}`);
                }

                const currentSymbol = this.tape[this.head_position] ?? this.blank_symbol;
                const transition = stateTransitions[currentSymbol];
                if (!transition) {
                    throw new Error(`No transition for symbol '${currentSymbol}' in state ${this.current_state} with input tape ${this.input_tape}`);
                }

                const [newState, newSymbol, moveDirection] = transition;

                if (newSymbol === this.blank_symbol) {
                    delete this.tape[this.head_position];
                } else {
                    this.tape[this.head_position] = newSymbol;
                }

                const shift = moveDirection === TuringConfig.LEFT ? -1 : 1;
                this.current_state = newState;
                this.head_position += shift;
            }

            runLogic(inputTape, maxSteps = 1_000_000, visualize = false) {
                this.input_tape = inputTape;
                this._setTape(inputTape);
                this._printTapeState(visualize);

                this.stepCount = 0;
                let tape = "";
                while (this.running && this.stepCount < maxSteps) {
                    if (this.current_state === this.halt_state) {
                        this.running = false;
                        if (visualize) {
                            console.log(`HALTED after ${this.stepCount} steps`);
                        }
                        continue;
                    }

                    this._stepLogic();
                    tape = this._printTapeState(visualize);
                    this.stepCount++;
                }

                return [tape, this.stepCount, this.transitions_list.length];
            }

            async runIncrementally(inputTape, visualize = true, maxSteps = 1_000_000) {
                console.log("Turing Machine Initialized:");
                console.log("Enter [space] to step, number to step n times, or q to quit:\n")
                this.stepCount = 0;
                let tape = "";

                this.input_tape = inputTape;
                this._setTape(inputTape);
                this._printTapeState(visualize);

                while (this.running && this.stepCount < maxSteps) {
                    if (this.current_state === this.halt_state) {
                        this.running = false;
                        if (visualize) {
                            console.log(`HALTED after ${this.stepCount} steps`);
                        }
                        break;
                    }
                    const key = await new Promise(resolve => {
                        process.stdin.resume();
                        process.stdin.setEncoding('utf8');
                        process.stdin.once('data', data => resolve(data.trim()));
                    });

                    if (key === 'q') {
                        console.log("Machine Stopped Manually");
                        break;
                    } else if (key === '' || key === ' ') {
                        this._stepLogic();
                        this.stepCount++;
                        tape = this._printTapeState(visualize);
                    } else if (/^\d+$/.test(key)) {
                        const stepsToRun = parseInt(key, 10);
                        for (let i = 0; i < stepsToRun; i++) {
                            if (this.current_state === this.halt_state || !this.running) break;
                            this._stepLogic();
                            this.stepCount++;
                            tape = this._printTapeState(visualize);
                        }
                    } else {
                        console.log(`Unrecognized key: '${key}'`);
                    }
                }

                return [tape, this.stepCount, this.transitions_list.length];
            }

        }

        class TuringSimulator_GUI {
            constructor() {
                this.init_time = TuringConfig.getTimestamp();
                this.MAX_STEPS = 0;
                this.BASE_STEP = 0;
                this.DELAY = 0;
                this.step_count = 0;
                this.running = false;
                this.auto_run_timeout = null;
                this.history = [];

                this.initElements();
                this.setupEventListeners();
                this.load();
            }

            initElements() {
                this.gotoBtn = document.getElementById('gotoBtn');
                this.loadBtn = document.getElementById('loadBtn');
                this.maxSteps = document.getElementById('maxSteps');
                this.resetBtn = document.getElementById('resetBtn');
                this.gotoStep = document.getElementById('gotoStep');
                this.stepEntry = document.getElementById('stepEntry');
                this.tapeInput = document.getElementById('tapeInput');
                this.rulesText = document.getElementById('rulesText');
                this.stepState = document.getElementById('stepState');
                this.delayEntry = document.getElementById('delayEntry');
                this.tapeDisplay = document.getElementById('tapeDisplay');
                this.RunPauseBtn = document.getElementById('RunPauseBtn');
                this.copyRulesBtn = document.getElementById('copyRulesBtn');
                this.historySlider = document.getElementById('historySlider');
                this.machineStatus = document.getElementById('machineStatus');
                this.clearRulesBtn = document.getElementById('clearRulesBtn');
                this.stepBtn = document.getElementById('stepBtn');
                this.results = document.getElementById('results');
                this.uploadBtn = document.getElementById('uploadBtn');
                this.fileInput = document.getElementById('fileInput');
                this.resources = document.getElementById('resources');
                this.ControlBtn = document.getElementById('ControlBtn');
            }

            setupEventListeners() {
                const withScrollToTop = (callback) => {
                    return (...args) => {
                        callback(...args);
                        window.scrollTo({ top: 0, behavior: 'smooth' });
                    };
                };

                this.historySlider.addEventListener('input', withScrollToTop(() =>
                    this.seekHistory(parseInt(this.historySlider.value))
                ));

                this.copyRulesBtn.addEventListener('click', withScrollToTop(() => this.copyRules()));
                this.clearRulesBtn.addEventListener('click', withScrollToTop(() => this.clearRules()));
                this.loadBtn.addEventListener('click', withScrollToTop(() => this.load()));
                this.resetBtn.addEventListener('click', withScrollToTop(() => this.reset()));
                this.gotoBtn.addEventListener('click', withScrollToTop(() => this.goToStep()));
                this.stepBtn.addEventListener('click', withScrollToTop(() => this.step()));

                // Connect upload button to file input
                this.uploadBtn.addEventListener('click', () => {
                    this.fileInput.click();
                });

                // Handle file selection
                this.fileInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const text = e.target.result.trim();
                            window.setRulesText(text);
                            this.load(); // Automatically load after upload
                        } catch (error) {
                            console.error("Error loading file:", error);
                            this.updateMachineStatus("Error loading file", "text-danger");
                            alert(`Error loading file: ${error.message}`);
                        }
                    };
                    reader.onerror = () => {
                        this.updateMachineStatus("Error reading file", "text-danger");
                        alert("Error reading file");
                    };
                    reader.readAsText(file);
                });

                this.RunPauseBtn.addEventListener('click', () => {
                    this.ControlBtn.click();
                });

                this.ControlBtn.addEventListener('click', () => {
                    if (this.running) {
                        this.pause();
                    } else if (this.cpu?.current_state === this.cpu?.halt_state) {
                        this.reset();
                    } else {
                        this.run();
                    }
                });

                this.updateControlButton('run');
            }

            load() {
                try {
                    const rules = window.getRulesText(); // Using the Ace Editor content
                    const transitions = new TuringConfig().parseTransitionRules(rules);
                    this.initial_tape = this.tapeInput.value || "||||";
                    this.init_time = TuringConfig.getTimestamp();
                    this.cpu = new MachineLogic(transitions);
                    this.cpu._setTape(this.initial_tape);

                    this.step_count = 0;
                    this.running = false;
                    this.updateControlButton('run');
                    this.updateMachineStatus("Machine Loaded", "text-secondary");
                    this.stepBtn.disabled = false;

                    this.history = [{
                        tape: { ...this.cpu.tape },
                        head: this.cpu.head_position,
                        state: this.cpu.current_state
                    }];

                    this.updateUI();
                } catch (error) {
                    console.error("Load error:", error);
                    this.updateMachineStatus(error, "text-danger");
                    alert(`Error during load: ${error.message}`);
                }
            }

            reset() {
                clearTimeout(this.auto_run_timeout);
                try {
                    if (!this.initial_tape) {
                        const status = "Initial configuration not loaded. Click 'Load' first."
                        this.updateMachineStatus(status, "text-warning")
                        alert(status);
                        return;
                    }
                    this.init_time = TuringConfig.getTimestamp();
                    this.cpu._setTape(this.initial_tape);
                    this.step_count = 0;
                    this.running = false;
                    this.stepBtn.disabled = false;
                    this.RunPauseBtn.disabled = false;
                    this.updateControlButton('run');
                    this.updateMachineStatus("Machine RESET", "text-secondary");

                    this.history = [{
                        tape: { ...this.cpu.tape },
                        head: this.cpu.head_position,
                        state: this.cpu.current_state
                    }];
                    this.updateUI();
                } catch (error) {
                    console.error("Reset error:", error);
                    this.updateMachineStatus(error, "text-danger");
                    alert(`Error during reset: ${error.message}`);
                }
            }

            step(printStep = true) {
                try {
                    const steps_to_run = parseInt(this.stepEntry.value) || this.BASE_STEP;
                    const max_allowed = parseInt(this.maxSteps.value) || this.MAX_STEPS;
                    if (printStep) {
                        this.updateMachineStatus(`Machine ran for ${steps_to_run} steps`, "text-primary");              // When started
                    }
                    for (let i = 0; i < steps_to_run; i++) {
                        if (this.step_count >= max_allowed) {
                            this.updateMachineStatus(`Max steps (${max_allowed}) reached`, "text-danger");
                            this.pause(false);
                            break;
                        }
                        if (this.cpu.current_state === this.cpu.halt_state) {
                            this.HALT();
                            break;
                        }

                        try {
                            this.cpu._stepLogic();
                            this.step_count++;

                            this.history.push({
                                tape: { ...this.cpu.tape },
                                head: this.cpu.head_position,
                                state: this.cpu.current_state
                            });

                            this.updateUI();

                        } catch (error) {
                            const textContent = `Machine STUCK | After ${this.step_count} steps`;
                            this.updateMachineStatus(textContent, "text-danger");
                            this.pause(false);
                            throw error;
                        }
                    }
                } catch (error) {
                    console.error("Step error:", error);
                    this.updateMachineStatus(error, "text-danger");
                    alert(`Error during step: ${error.message}`);
                }
            }

            pause(printPause = true) {
                if (printPause) {
                    this.updateMachineStatus(`Machine Paused after ${this.step_count} steps`, "text-warning");
                }
                this.running = false;
                clearTimeout(this.auto_run_timeout);
                this.updateControlButton('run');
                this.stepBtn.disabled = false;
            }

            HALT() {
                this.running = false;
                this.stepBtn.disabled = true;

                this.updateControlButton('reset');
                this.RunPauseBtn.disabled = true
                const textContent = `Machine HALTED | Total Steps: ${this.step_count}`;
                this.updateMachineStatus(textContent, "text-success");    // On halt
            }

            run() {
                this.running = true;
                this.stepBtn.disabled = true;

                this.updateControlButton('pause');
                this.autoStep();
            }

            autoStep() {
                if (!this.running) return;
                if (this.cpu.current_state === this.cpu.halt_state) {
                    this.HALT();
                    return;
                }
                this.updateMachineStatus("Machine AutoRun", "text-primary");              // When started

                this.step(false);

                const delay = parseInt(this.delayEntry.value) || this.DELAY;
                this.auto_run_timeout = setTimeout(() => this.autoStep(), delay);
            }

            seekHistory(step) {
                step = parseInt(step);
                if (isNaN(step)) return;

                if (step < 0 || step >= this.history.length) {
                    return;
                }

                const snapshot = this.history[step];
                this.cpu.tape = { ...snapshot.tape };
                this.cpu.head_position = snapshot.head;
                this.cpu.current_state = snapshot.state;
                this.step_count = step;
                this.updateUI();
            }

            goToStep() {
                const step = parseInt(this.gotoStep.value);
                if (isNaN(step)) {
                    alert("Please enter a valid step number");
                    return;
                }

                if (step < 0 || step > this.history.length - 1) {
                    alert(`Step must be between 0 and ${this.history.length - 1}`);
                    return;
                }

                this.historySlider.value = step;
                this.seekHistory(step);
            }

            updateUI() {
                // Update tape display
                this.tapeDisplay.innerHTML = "";

                const positions = Object.keys(this.cpu.tape).map(Number);
                const min_pos = positions.length > 0 ? Math.min(...positions) : 0;
                const max_pos = positions.length > 0 ? Math.max(...positions) : 0;

                // Show at least 5 cells before and after the head position
                const start_pos = Math.min(min_pos, this.cpu.head_position) - 5;
                const end_pos = Math.max(max_pos, this.cpu.head_position) + 5;

                for (let pos = start_pos; pos <= end_pos; pos++) {
                    const cell = document.createElement('div');
                    cell.className = 'tape-cell';
                    cell.textContent = this.cpu.tape[pos] !== undefined ? this.cpu.tape[pos] : this.cpu.blank_symbol;
                    if (pos === this.cpu.head_position) {
                        cell.classList.add('active');
                    }
                    this.tapeDisplay.appendChild(cell);
                }
                // Scroll the active cell horizontally without affecting vertical position
                const activeCell = this.tapeDisplay.querySelector('.active');
                if (activeCell) {
                    activeCell.scrollIntoView({
                        behavior: 'auto',
                        block: 'nearest',  // This prevents vertical scrolling
                        inline: 'center'   // This handles horizontal scrolling
                    });
                }

                // Restore vertical scroll position
                window.scrollTo(0, scrollY);


                // Update status
                this.historySlider.max = this.history.length - 1;
                this.historySlider.value = this.step_count;
                this.gotoStep.value = this.step_count;

                // Update step state display
                this.updateStepState();

                // Update results
                this.updateResults();
            }

            updateResults() {
                this.cpu.stepCount = this.step_count;
                const final_tape = this.cpu._printTapeState();
                const resources_used = [
                    `    Time run: ${(TuringConfig.getTimestamp() - this.init_time).toFixed(5)}s`,
                    ` Memory used: ${TuringConfig.getCurrentMemoryMB()}MB`
                ];

                const results = [
                    `Initial Tape: '${this.initial_tape}'`,
                    ` Result Tape: '${final_tape}'`,
                    ` Steps Count: ${this.step_count}`,
                    ` Total Rules: ${this.cpu.transitions_list.length}`,
                    ...resources_used
                ];

                this.results.innerHTML = results.join('<br>');

            }

            updateStepState() {
                const step = parseInt(this.historySlider.value);
                const prev = step > 0 ? this.history[step - 1].state : "--";
                const curr = this.history[step].state;
                const next = step + 1 < this.history.length ? this.history[step + 1].state : 
                    (step === this.step_count ? "--" : "--");
                this.stepState.innerHTML = ` Step [${step}]: ${prev} <- <span class="tape-current">${curr}</span> -> ${next}`;

            }

            updateControlButton(state) {
                const btn_ctrl = this.ControlBtn;
                btn_ctrl.className = 'control-btn'; // Reset classes

                const btn_rp = this.RunPauseBtn;
                btn_rp.className = 'btn w-100 action-btn';

                switch(state) {
                    case 'run':
                        btn_ctrl.classList.add('btn-run');
                        btn_rp.classList.add('btn-run');
                        btn_ctrl.innerHTML = '<i class="bi bi-play-fill"></i>';
                        btn_rp.innerHTML = '<i class="bi bi-play-fill"></i>Run';
                        break;
                    case 'pause':
                        btn_ctrl.classList.add('btn-pause');
                        btn_rp.classList.add('btn-pause');
                        btn_ctrl.innerHTML = '<i class="bi bi-pause-fill"></i>';
                        btn_rp.innerHTML = '<i class="bi bi-pause-fill"></i>Pause';
                        break;
                    case 'reset':
                        btn_ctrl.classList.add('btn-reset');
                        btn_rp.classList.add('btn-run');
                        btn_ctrl.innerHTML = '<i class="bi bi-arrow-clockwise"></i>';
                        btn_rp.innerHTML = '<i class="bi bi-play-fill"></i>Run';
                        break;
                }
            }

            updateMachineStatus(text, colorClass = "text-primary") {
                const statusEl = document.getElementById("machineStatus");
                statusEl.className = `text-machineStatus fw-bold text-center ${colorClass}`;
                statusEl.textContent = text;
            }

            copyRules() {
                const rules = window.getRulesText();

                if (!rules.trim()) {
                    alert("No rules to copy");
                    return;
                }

                navigator.clipboard.writeText(rules)
                    .then(() => alert("Transition rules copied to clipboard"))
                    .catch(err => {
                        console.error("Failed to copy rules:", err);
                        alert("Failed to copy rules. Please try again.");
                    });
            }

            clearRules() {
                if (confirm("Are you sure you want to clear all transition rules?")) {
                    window.setRulesText("");
                }
            }

        }

        // Make editor available globally
        window.getRulesText = () => editor.getValue();
        window.setRulesText = (text) => editor.setValue(text);

        // Initialize GUI
        new TuringSimulator_GUI();
                    // Populate help section
        document.getElementById('initStatePlaceholder').textContent = TuringConfig.INIT_STATE;
        document.getElementById('haltStatePlaceholder').textContent = TuringConfig.HALT_STATE;
        document.getElementById('blankSymbolPlaceholder').textContent = TuringConfig.BLANK;
        document.getElementById('maxStatesPlaceholder').textContent = TuringConfig.MAX_STATES.toLocaleString();
        document.getElementById('maxTapeLenPlaceholder').textContent = TuringConfig.MAX_TAPE_LEN.toLocaleString();
        document.getElementById('maxStateSizePlaceholder').textContent = TuringConfig.MAX_STATE_SIZE;
        document.getElementById('transitionSizePlaceholder').textContent = TuringConfig.TRANSITION_SIZE.toLocaleString();

    </script>
</body>
</html>