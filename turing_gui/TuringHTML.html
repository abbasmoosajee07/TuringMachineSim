<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Turing Machine Simulator</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <!-- Basic SEO -->
        <meta name="description" content="Interactive Turing Machine Simulator — Build, animate, and visualize customizable Turing machines with step-by-step control, tape GIFs, and full configuration options.">
        <meta name="keywords" content="Turing machine, Turing machine simulator, automata theory, computation theory, state diagram, tape simulation, finite automata, computer science education">
        <meta name="robots" content="index, follow">
        <!-- Stylesheets -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.6/ace.min.css">
        <style>
        /* ===== ROOT VARIABLES ===== */
        :root {
        /* Color Scheme */
        --primary-color: #fd490d;      /* Bright orange */
        --primary-hover: #ff8a5c;      /* Lighter orange */
        --reconfigure-bg: #fa5656;     /* Vivid red (danger/reset) */

        /* Button Colors */
        --reset-bg: #ff4e3a;           /* Vivid red */
        --goto-bg: #16a085;            /* Teal */
        --step-bg: #d820a4;            /* Hot magenta */
        --run-bg: #f39c12;             /* Orange-yellow */
        --pause-bg: #f1c40f;           /* Bright yellow */
        --upload-bg: #d35400;          /* Burnt orange */
        --save-bg: #2ecc71;            /* Green */
        
        /* GIF Controls */
        --buildgif: #7f8c8d;           /* Neutral gray */
        --cancelgif: #c0392b;          /* Strong red */
        --savegif: #27ae60;            /* Bold green */
        --rendergif: #3498db;          /* Clean blue */

        /* Interaction */
        --hover-brightness: 1.25;
        --active-brightness: 0.85;

        /* Modal Colors */
        --tm-primary: #6366f1;
        --tm-primary-dark: #4f46e5;
        --tm-primary-light: #e0e7ff;
        --tm-bg: #ffffff;
        --tm-surface: #ffffff;
        --tm-surface-light: #f9fafb;
        --tm-surface-dark: #f3f4f6;
        --tm-text: #111827;
        --tm-text-secondary: #6b7280;
        --tm-border: #e5e7eb;
        --tm-border-dark: #d1d5db;
        }

        /* ===== BASE STYLES ===== */
        body {
        background-color: #f5f5f5;
        font-size: 0.9rem;
        margin: 0 !important;
        }

        .container, .container-fluid {
        padding: 0 5%;
        }

        /* ===== TYPOGRAPHY ===== */
        .monospace,
        .rules-info,
        .form-label,
        .tm-rules-editor {
        font-family: monospace;
        }

        .stepState, .step-state, .machineStatus {
        font-weight: 300;
        letter-spacing: 0.35px;
        }

        .stepState { font-size: 1.15rem; }
        .step-state { font-size: 1.25rem; }
        .machineStatus { 
        font-size: 1.25rem !important;
        transition: all 0.3s ease;
        }

        .step-index { color: var(--primary-color); }

        /* ===== HEADER ===== */
        .app-header {
        background-color: #f6f8f9;
        border-bottom: 1px solid #ddd;
        padding: 4px 4px 0 2px;
        }

        .app-header-title {
        font-family: 'Helvetica';
        font-weight: 100 !important;
        letter-spacing: 2px;
        color: #222;
        margin-left: -20px;
        font-size: 30px;
        }

        .header-buttons { display: flex; align-items: center; }

        .header-btn {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 38px;
        height: 38px;
        background-color: #dedede;
        border: 1px solid #ddd;
        border-radius: 8px;
        font-size: 1.2rem;
        color: #333;
        cursor: pointer;
        transition: all 0.2s ease;
        }

        .header-btn:hover { filter: brightness(var(--active-brightness)) !important; box-shadow: 0 2px 6px rgba(0,0,0,0.08); }
        .header-btn:active { filter: brightness(var(--hover-brightness)) !important; }

        /* ===== INPUTS & CONTROLS ===== */
        input:focus, input:hover, 
        input.form-control:focus {
        outline: none !important;
        box-shadow: none !important;
        border-color: var(--primary-hover);
        }

        .slider-primary {
        /* WebKit slider styles */
        &::-webkit-slider-thumb {
            background-color: var(--primary-color);
            border: none;
            border-radius: 50%;
            height: 16px;
            width: 16px;
            margin-top: -6px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        &:hover::-webkit-slider-thumb {
            background-color: var(--primary-hover);
            transform: scale(1.05);
        }
        
        &::-webkit-slider-runnable-track {
            background-color: #ddd;
            height: 6px;
            border-radius: 3px;
        }
        }

        /* ===== CARDS ===== */
        .card {
        margin: 20px 5px;
        box-shadow: 0 2px 4px rgba(29, 29, 29, 0.1);
        }

        .card-header {
        font-weight: bold;
        font-size: 1.05rem;
        background-color: #f9f9f9;
        color: #333;
        padding: 0.4rem 0.8rem;
        border-bottom: 1px solid #dee2e6;
        letter-spacing: 0.5px;
        }

        /* ===== TAPE DISPLAY ===== */
        .tape-wrapper {
        width: 100%;
        overflow-x: auto;
        padding: 10px 0;
        margin: 10px 0;
        background-color: #f9f9f9;
        border-radius: 2px;
        border: 1pt solid #ccc;
        scrollbar-width: thin;
        scrollbar-color: #888 #f1f1f1;
        }

        .tape-container {
        display: inline-flex;
        min-width: 100%;
        padding: 1px 0;
        
        &::-webkit-scrollbar {
            height: 8px;
            &-track { background: #f1f1f1; border-radius: 4px; }
            &-thumb { 
            background: #888; 
            border-radius: 4px;
            &:hover { background: #555; }
            }
        }
        }

        .tape-cell {
        min-width: 50px;
        width: 50px;
        height: 50px;
        border: 1px solid #ddd;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 2px;
        font-size: 21px;
        background-color: white;
        flex-shrink: 0;
        font-weight: 700;
        line-height: 40px;
        
        &.active {
            border: 6px solid var(--primary-color);
            font-weight: 900;
        }
        }

        .tape-current {
        color: var(--primary-color);
        font-weight: bold;
        }

        /* ===== BUTTONS ===== */
        .btn {
            display: inline-block;
            vertical-align: middle;
            text-align: center;
            font-weight: 550;
            color: black !important;
            transition: filter 0.2s ease, background-color 0.2s ease;
            user-select: none;
            white-space: normal !important;
            padding: 0.25rem 0.25rem;
            font-size: 1.05rem;

        i { margin-right: 5px; }
        
        &:hover, &:focus, &:focus-visible {
            filter: brightness(var(--hover-brightness)) !important;
            transform: scale(1.05);
        }
        
        &:active { filter: brightness(var(--active-brightness)) !important; }
        
        &:disabled {
            background-color: #e0e0e0 !important;
            color: #888 !important;
            border-color: #ccc !important;
            cursor: not-allowed !important;
            opacity: 1 !important;
            filter: none !important;
            transform: none !important;
        }
        }

        /* Button Variants */
        .btn-reset { background-color: var(--reset-bg) !important; }
        .btn-goto { background-color: var(--goto-bg) !important; }
        .btn-step { background-color: var(--step-bg) !important; }
        .btn-run { background-color: var(--run-bg) !important; }
        .btn-pause { background-color: var(--pause-bg) !important; }
        .btn-buildgif { background-color: var(--buildgif) !important; }
        .btn-rendergif { background-color: var(--rendergif) !important; }
        .btn-savegif { background-color: var(--savegif) !important; }
        .btn-cancelgif { background-color: var(--cancelgif) !important; }
        .btn-reconfigure { background-color: var(--reconfigure-bg) !important; }
        .btn-upload { background-color: var(--upload-bg) !important; }
        .btn-save { background-color: var(--save-bg) !important; }

        .btn-group { margin-top: 15px; }

        .control-btn {
        position: fixed;
        bottom: 1.75vmin;
        right: 1.75vmin;
        width: 4.75vmin;
        height: 4.75vmin;
        min-width: 50px;
        min-height: 50px;
        border-radius: 50%;
        font-size: calc(16px + 2vmin);
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        z-index: 2000;
        display: flex;
        align-items: center;
        justify-content: center;
        border: none;
        transition: all 0.3s ease;
        
        &:hover { transform: scale(1.15); }
        }

        /* ===== CONFIGURATION ===== */
        .config-list {
        list-style: none;
        padding-left: 0;
        margin-bottom: 0;
        }

        .config-item {
        display: flex;
        align-items: center;
        margin-bottom: 0;
        margin-left: 1rem;
        }

        .config-input, .config-label {
        border: none;
        background-color: transparent;
        outline: none;
        font-size: 16px;
        }

        .config-label { font-weight: 600; }
        .config-input { 
        color: red;
        font-weight: 400;
        &:focus { font-weight: 700 !important; }
        }

        /* ===== MODAL SYSTEM ===== */
        .tm-modal {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
        
        &.active {
            opacity: 1;
            pointer-events: all;
            
            .tm-modal-content { transform: translateY(0); }
        }
        }

        .tm-modal-backdrop {
        position: absolute;
        inset: 0;
        background-color: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(4px);
        }

        .tm-modal-container {
        position: relative;
        width: 100%;
        max-width: 600px;
        max-height: 90vh;
        margin: 20px;
        overflow-y: auto;
        outline: none;
        }

        .tm-modal-content {
        background-color: var(--tm-surface);
        border-radius: 12px;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        overflow: hidden;
        border: 1px solid var(--tm-border);
        transform: translateY(20px);
        transition: transform 0.3s ease;
        }

        /* Modal Sections */
        .tm-modal-header {
        padding: 20px 20px 12px;
        border-bottom: 1px solid var(--tm-border);
        
        h3 { margin: 0; font-size: 20px; font-weight: 600; color: var(--tm-text); }
        p { margin-top: 8px; font-size: 14px; color: var(--tm-text-secondary); }
        }

        .tm-modal-body { padding: 24px; }
        .tm-modal-footer {
        display: flex;
        justify-content: flex-end;
        gap: 12px;
        padding: 16px 24px;
        border-top: 1px solid var(--tm-border);
        }

        .tm-modal-close {
        position: absolute;
        top: 12px;
        right: 12px;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        background: transparent;
        border: none;
        cursor: pointer;
        color: var(--tm-text-secondary);
        transition: all 0.2s ease;
        z-index: 10;
        
        &:hover {
            background: rgba(0, 0, 0, 0.05);
            color: var(--tm-text);
        }
        }

        /* Form Elements */
        .tm-input-group { display: flex; align-items: center; margin-bottom: 12px; }

        .tm-input-prefix {
        background-color: var(--tm-surface-light);
        border: 1px solid var(--tm-border);
        border-right: none;
        padding: 0.5em 0.75em;
        border-radius: 6px 0 0 6px;
        font-size: 14px;
        color: var(--tm-text-secondary);
        user-select: none;
        }

        .tm-form-control {
        flex: 1;
        padding: 0.5em 0.75em;
        font-size: 14px;
        border: 1px solid var(--tm-border);
        border-radius: 0 6px 6px 0;
        color: var(--tm-text);
        outline-offset: 2px;
        transition: border-color 0.2s ease;
        
        &:focus {
            border-color: var(--tm-primary);
            box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2);
            outline: none;
        }
        }

        /* File Dropzone */
        .tm-file-dropzone {
        border: 2px dashed var(--tm-border-dark);
        border-radius: 8px;
        padding: 22px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        cursor: pointer;
        background-color: var(--tm-surface-light);
        transition: all 0.2s ease;
        user-select: none;
        
        &:hover {
            border-color: var(--tm-primary);
            background-color: var(--tm-primary-light);
        }
        
        p { margin: 0; font-size: 14px; color: var(--tm-text-secondary); }
        }

        /* File Preview */
        .tm-file-preview-chip {
            display: inline-flex;
            align-items: center;
            background: #e0e0e0;
            padding: 0.25em 0.5em;
            border-radius: 16px;
            margin: 0.5em 0;
            font-size: 0.9em;
            cursor: default;
        }

        .tm-file-preview-chip span {
            margin-right: 0.5em;
        }

        .tm-file-preview-chip button {
            background: transparent;
            border: none;
            cursor: pointer;
            font-weight: bold;
            line-height: 1;
            padding: 0 0.25em;
        }

        /* Editor Styles */
        .tm-rules-editor {
            width: 100%;
            min-height: 100px;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid var(--tm-border);
            background-color: var(--tm-surface-light);
            color: var(--tm-text);
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.5;
            resize: vertical;
            transition: border-color 0.2s ease;
        }

        .tm-rules-editor:focus {
            outline: none;
            border-color: var(--tm-primary);
            box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2);
        }

        /* Export Options */
        .tm-export-options {
        display: flex;
        flex-direction: column;
        gap: 4px;
        }

        .tm-export-option {
        position: relative;
        
        input[type="radio"] { position: absolute; opacity: 0; }
        
        label {
            display: block;
            padding: 6px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        &:hover label { background-color: var(--tm-surface-light); }
        
        input[type="radio"]:checked + .tm-option-content {
            background-color: var(--tm-primary-light);
            border-color: var(--tm-primary);
        }
        }

        .tm-option-content {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 10px;
        border-radius: 6px;
        border: 1px solid var(--tm-border);
        transition: all 0.2s ease;
        }

        .tm-option-icon {
        width: 22px;
        height: 22px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 6px;
        color: var(--tm-primary);
        
        i { font-size: 30px !important; padding: 2 !important; }
        }

        .tm-option-details { flex: 1; }

        .tm-option-title {
        font-size: 14px;
        font-weight: 500;
        margin-bottom: 4px;
        color: var(--tm-text);
        }

        .tm-option-description { font-size: 13px; }

        /* Grid Layout */
        .grid-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
            margin-top: 12px;
        }

        /* Option Card Styling */
        .tm-export-option {
            position: relative;
        }

        .tm-export-option input[type="radio"] {
            position: absolute;
            opacity: 0;
        }

        .tm-export-option label {
            display: block;
            height: 100%;
            cursor: pointer;
        }

        .tm-option-content {
            height: 100%;
            padding: 16px;
            border-radius: 8px;
            border: 1px solid var(--tm-border);
            transition: all 0.2s ease;
            background-color: var(--tm-surface);
        }

        .tm-export-option input[type="radio"]:checked + label .tm-option-content {
            border-color: var(--tm-primary);
            background-color: var(--tm-primary-light);
            box-shadow: 0 0 0 1px var(--tm-primary);
        }

        .tm-export-option:hover .tm-option-content {
            border-color: var(--tm-primary-dark);
        }

        /* Icon Styling */
        .tm-option-icon {
            font-size: 24px;
            color: var(--tm-primary);
            margin-bottom: 8px;
        }

        /* Text Styling */
        .tm-option-title {
            font-weight: 600;
            margin-bottom: 4px;
            color: var(--tm-text);
        }

        .tm-option-description {
            font-size: 0.875rem;
            color: var(--tm-text-secondary);
            line-height: 1.4;
        }

        /* Icon Buttons */
        .tm-icon-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 25px !important;
        height: 25px !important;
        font-size: 16px !important;
        border: 1px solid var(--tm-border);
        border-radius: 6px;
        background-color: var(--tm-surface-light);
        color: var(--tm-text-secondary);
        cursor: pointer;
        padding: 0 !important;
        margin: 0% !important;
        transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease;
        }


        /* Success (green) for copy */
        .tm-icon-btn-success {
        color: #15803d;
        border-color: #bbf7d0;
        background-color: #f0fdf4;
        }

        .tm-icon-btn-success:hover {
        background-color: #dcfce7;
        border-color: #86efac;
        color: #166534;
        }

        /* Danger (red) for clear */
        .tm-icon-btn-danger {
        color: #dc2626;
        border-color: #fecaca;
        background-color: #fef2f2;
        }

        .tm-icon-btn-danger:hover {
        background-color: #fee2e2;
        border-color: #fca5a5;
        color: #b91c1c;
        }

        /* ===== RESPONSIVE ADJUSTMENTS ===== */
        @media (max-width: 900px) {
        .app-header-title {
            font-size: 27px;
            margin-left: -10px;
        }
        }

        @media (max-width: 768px) {
        .control-btn {
            bottom: 2vmin;
            right: 2vmin;
            width: 6vmin;
            height: 6vmin;
        }
        }

        @media (max-width: 600px) {
        .app-header-title {
            font-size: 14px;
            margin-left: 0;
        }
        
        .tm-action-buttons { flex-direction: column; }
        .tm-rules-editor { min-height: 200px; }
        }

        @media (max-width: 576px) {
        .header-btn {
            width: 32px;
            height: 32px;
            font-size: 1rem;
        }
        }

        </style>
    </head>

    <body>
        <!-- Page Header -->
        <header class="app-header mt-0 mb-0">
            <div class="container-fluid d-flex justify-content-between align-items-center">
                <div class="d-flex align-items-center gap-2">
                    <div class="app-header-title">Turing Machine Simulator</div>
                    <div class="dropdown">
                        <button class="form-control form-control-sm fst-italic dropdown-toggle"
                                id="examplesDropdown"
                                type="button"
                                data-bs-toggle="dropdown"
                                aria-expanded="false"
                                style="max-width: 250px; font-style: italic; cursor: pointer; text-align: left; background-color: white;">
                        </button>
                        <ul class="dropdown-menu" id="examplesMenu" aria-labelledby="examplesDropdown" style="max-width: 500px;">
                            <li class="dropdown-item fst-italic text-muted">Loading examples...</li>
                        </ul>
                    </div>
                </div>
                <div class="header-buttons d-flex gap-2">
                    <button id="importBtn" class="header-btn" title="Import your model into the machine">
                        <i class="bi bi-folder-fill"></i>
                    </button>
                    <button id="exportBtn" class="header-btn" title="Save your model in different formats">
                        <i class="bi bi-folder-symlink-fill"></i>
                    </button>
                </div>
            </div>
        </header>

        <!-- Import Modal -->
        <div id="importModal" class="tm-modal">
        <div class="tm-modal-backdrop"></div>
        <div class="tm-modal-container">
            <div class="col md-4 tm-modal-content">
            <button class="tm-modal-close" data-dismiss="modal" id = "closeImport">
                <i class="bi bi-x-lg"></i>
            </button>

            <div class="tm-modal-header">
                <h3>Import</h3>
            </div>

            <div class="tm-modal-body">
                <!-- File upload section -->
                <div class="tm-import-section">

                <h4>From Local Files</h4>
                <div class="tm-file-dropzone">
                    <div class="tm-option-icon">
                        <i class="bi bi-upload" style="font-size: 2rem;"></i>
                    </div>
                    <p>Supported file types: <strong>.json, .jsonl, .yaml, .txt</strong></p>
                    <p>Click to select or drag &amp; drop files here</p>
                    <input
                    id="fileInput"
                    type="file"
                    name="files"
                    multiple
                    class="tm-file-input"
                    accept=".json,.jsonl,.yaml,.txt"
                    style="display: none;"
                    />
                </div>
                </div>
                <h6>Model Preview</h6>
                <textarea id="importPreview" class="tm-rules-editor" placeholder="View your model here..." readonly></textarea>
            </div>
            </div>

            <!-- Preview section -->
            <div class="tm-modal-preview">
                <div id="filePreviewContainer" class="tm-file-preview-container"></div>
            </div>

            <div class="tm-modal-footer">
            <button id="importConfirmBtn" class="btn btn-upload w-100 action-btn" disabled>
                Load Model
            </button>
            </div>
        </div>
        </div>

        <!-- Export Modal -->
        <div id="exportModal" class="tm-modal">
        <div class="tm-modal-backdrop"></div>
        <div class="tm-modal-container">
            <div class="tm-modal-content">
            <button class="tm-modal-close" id = "closeExport">
                <i class="bi bi-x-lg"></i>
            </button>

            <div class="tm-modal-header">
                <h3>Export</h3>
            </div>

            <div class="tm-modal-body">

                <div class="tm-export-options grid-container">
                <div class="tm-export-option">
                    <input type="radio" name="exportFormat" value="json" id="export-json">
                    <label for="export-json">
                    <div class="tm-option-content">
                        <div class="tm-option-icon">
                        <i class="bi bi-filetype-json"></i>
                        </div>
                        <div class="tm-option-details">
                        <div class="tm-option-title">JSON</div>
                        <div class="tm-option-description">Basic and Structured data format</div>
                        </div>
                    </div>
                    </label>
                </div>

                <div class="tm-export-option">
                    <input type="radio" name="exportFormat" value="jsonl" id="export-jsonl">
                    <label for="export-jsonl">
                    <div class="tm-option-content">
                        <div class="tm-option-icon">
                        <i class="bi bi-filetype-json"></i>
                        </div>
                        <div class="tm-option-details">
                        <div class="tm-option-title">JSONLines</div>
                        <div class="tm-option-description">Structured state, Ideal for storing large histories</div>
                        </div>
                    </div>
                    </label>
                </div>

                <div class="tm-export-option">
                    <input type="radio" name="exportFormat" value="yaml" id="export-yaml">
                    <label for="export-yaml">
                    <div class="tm-option-content">
                        <div class="tm-option-icon">
                        <i class="bi bi-filetype-yml"></i>
                        </div>
                        <div class="tm-option-details">
                        <div class="tm-option-title">YAML</div>
                        <div class="tm-option-description">Ideal for initial models, and manual editing</div>
                        </div>
                    </div>
                    </label>
                </div>

                <div class="tm-export-option">
                    <input type="radio" name="exportFormat" value="txt" id="export-txt">
                    <label for="export-txt">
                    <div class="tm-option-content">
                        <div class="tm-option-icon">
                        <i class="bi bi-filetype-txt"></i>
                        </div>
                        <div class="tm-option-details">
                        <div class="tm-option-title">Plain Text</div>
                        <div class="tm-option-description">For Transition Rules ONLY</div>
                        </div>
                    </div>
                    </label>
                </div>
                </div>

                <h6>File Preview</h6>
                <textarea id="exportPreview" class="tm-rules-editor" placeholder="View your model here..." readonly></textarea>
            </div>
            </div>

            <div class="tm-modal-footer">
                <button id="saveBtn" class="btn btn-save w-100 action-btn">Save File</button>
            </div>
        </div>
        </div>

        <!-- Control button -->
        <button id="ControlBtn" class="control-btn bi bi-play-fill" title = ""></button>

        <!-- Main GUI-->
        <div class="container-fluid mt-3 mb-0">
            <!-- Ticker Tape Card -->
            <div id = "tapeCard" class="card mb-0 mt-0 shadow-sm">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <span class="fw-bold">Ticker Tape</span>
                    <div class="gif-controls d-flex align-items-center gap-2">
                        <button id="buildGIF" class="btn btn-buildgif w-100 action-btn bi bi-camera-reels-fill py-1 px-1 small"> Capture GIF</button>
                    </div>
                </div>

                <div class="card-body">
                    <!-- Tape Display -->
                    <div class="tape-wrapper border rounded p-3 bg-light mb-2 mt-0">
                        <div id="tapeDisplay" class="tape-container"></div>
                    </div>

                    <!-- Machine Status -->
                    <div id="machineStatus" class="machineStatus fw-bold text-center text-secondary mb-1"></div>

                    <!-- History Slider -->
                    <div class="d-flex align-items-center gap-2 mb-0">
                        <label for="historySlider" class="form-label mb-0 text-nowrap">History:</label>
                        <input type="range" class="slider-primary form-range flex-grow-1" id="historySlider" min="0" max="0" value="0">
                    </div>

                    <!-- Step Info -->
                    <div id="stepState" class="step-state text-center text-muted small"></div>
                </div>
            </div>

            <!-- Tape GIF Card -->
            <div id="gifCard" class="card mt-3 mb-0" style="display: none;">
                <div class="card-header"> Tape GIF</div>

                <!-- GIF Controls Section -->
                <div class="card-body mt-0 mb-0">
                    <div class="row g-3 align-items-center justify-content-between mb-1">

                        <!-- Left Column: Controls -->
                        <div class="col-auto d-flex flex-wrap align-items-center gap-2">

                            <!-- Delay -->
                            <div class="d-flex align-items-center">
                                <label for="gifSpeed" class="me-1 mb-0 small">FPS(ms):</label>
                                <input type="number" id="gifSpeed" class="form-control text-center"
                                    style="width: 60px; height: 24px; padding: 0 4px; font-size: 12px;"
                                    min="50" max="5000" step="50" value="500" title="GIF animation speed">
                            </div>

                            <!-- Cells -->
                            <div class="d-flex align-items-center">
                                <label for="visibleCells" class="me-1 mb-0 small">Cells:</label>
                                <input type="number" id="visibleCells" class="form-control text-center"
                                    style="width: 50px; height: 24px; padding: 0 4px; font-size: 12px;"
                                    min="1" max="99" value="15" title="Display number of cells">
                            </div>

                            <!-- Resolution -->
                            <div class="d-flex align-items-center">
                                <label for="resolution" class="me-1 mb-0 small">Res:</label>
                                <input type="number" id="resolution" class="form-control text-center"
                                    style="width: 50px; height: 24px; padding: 0 4px; font-size: 12px;"
                                    min="1" max="99" value="2" title="Resolution: Higher improves quality, increases memory and render time">
                            </div>

                            <!-- Color -->
                            <div class="d-flex align-items-center">
                                <label for="gifColor" class="me-1 mb-0 small">Color:</label>
                                <input type="color" id="gifColor" class="form-control form-control-color p-0"
                                    style="width: 28px; height: 24px;" value="#fd490d" title="Active cell color">
                            </div>
                        </div>

                        <!-- Status Area -->
                        <div class="col-auto d-flex align-items-center">
                            <div id="GIFStatus" class="machineStatus text-medium text-center" style="min-height: 24px;"></div>
                        </div>

                        <!-- Buttons -->
                        <div class="col-auto d-flex align-items-center gap-2">
                            <button id="generateGIF" class="btn btn-rendergif action-btn">
                                <i class="bi bi-film" title="Render GIF based on current history"></i> Render
                            </button>
                            <button id="cancelGIF" class="btn btn-cancelgif action-btn">
                                <i class="bi bi-x-circle-fill" title="Cancel current rendering"></i> Cancel
                            </button>
                            <a id="downloadGIF" class="btn btn-savegif action-btn" download="turing-machine.gif">
                                <i class="bi bi-filetype-gif" title="Download GIF"></i> Save
                            </a>
                        </div>
                    </div>
                </div>

                <!-- GIF Preview -->
                <div id="gifContainer" class="card-body mt-0 mb-0" style="display: none;">
                    <div class="preview-image mb-2">
                        <img id="gifPreview" class="img-fluid border rounded shadow-sm"
                            alt="GIF Preview">
                    </div>
                </div>

            </div>

            <!-- Controls and Configuration -->
            <div id = "fullControls" class="row mt-0 mb-0 align-items-stretch">
                <!-- Configure Model -->
                <div class="col-md-8 mb-2" id= "modelConfigure">
                    <div class="card h-95">
                        <div class="card-header mb-0 d-flex align-items-center justify-content-between">
                            <span>Configure Model</span>
                            <input type="text" id="modelInputName"
                                class="form-control form-control-sm ms-2 fst-italic"
                                placeholder="turing_test..."
                                style="max-width: 200px; font-style: italic;">
                        </div>

                        <div class="card-body">
                            <!-- Transition Rules -->
                            <div class="mb-1">
                                <div class="row align-items-center g-2">
                                    <div class="col-12 col-md-4">
                                        <label for="rulesEditor" class="form-label">Transition Rules:</label>
                                    </div>
                                    <div class="col text-end small">
                                        <button id="copyRulesBtn" class="tm-icon-btn tm-icon-btn-success" title="Copy Rules">
                                            <i class="bi bi-clipboard-fill"></i>
                                        </button>

                                        <button id="clearRulesBtn" class="tm-icon-btn tm-icon-btn-danger" title="Clear Rules">
                                            <i class="bi bi-trash-fill"></i>
                                        </button>
                                    </div>
                                </div>
                                <div id="rulesEditor" class="form-control h-100"
                                style="min-height: 232px; white-space: pre-wrap;" title="Rules Editor"></div>
                            </div>

                            <!-- Initial Tape -->
                            <div class="mb-0">
                                <div class="row align-items-center g-2">
                                    <div class="col-12 col-md-4">
                                        <label for="tapeInput" class="form-label mb-0">Initial Tape:</label>
                                    </div>
                                    <div class="col text-end small">
                                        <button id="copyTapeBtn" class="tm-icon-btn tm-icon-btn-success" title="Copy Tape">
                                            <i class="bi bi-clipboard-fill"></i>
                                        </button>

                                        <button id="clearTapeBtn" class="tm-icon-btn tm-icon-btn-danger" title="Clear Tape">
                                            <i class="bi bi-trash-fill"></i>
                                        </button>
                                    </div>
                                </div>
                                <input type="text" id="tapeInput" class="form-control" value="|||||||||">
                            </div>

                        </div>
                    </div>
                </div>

                <!-- Control Machine -->
                <div class="col-md-4 mb-2" id = "machineControls">
                    <div class="card h-95">
                        <div class="card-header">Control Machine</div>
                        <div class="card-body d-flex flex-column">
                            <!-- Step Navigation -->
                            <div class="mb-1 mt-1">
                                <div class="row align-items-center g-2">
                                    <div class="col-4">
                                        <label for="gotoStep" class="form-label mb-0 w-100">Seek Step:</label>
                                    </div>
                                    <div class="col-4">
                                        <input type="number" id="gotoStep" class="form-control" min="0" title="Seek specific step in history">
                                    </div>
                                    <div class="col-4">
                                        <button class="btn btn-goto w-100 action-btn bi bi-signpost-fill" id="gotoBtn">Seek</button>
                                    </div>
                                </div>
                            </div>

                            <!-- Configuration Options -->
                            <div class="mb-1 mt-1">
                                <label for="stepEntry" class="form-label mb-0">Jump Steps:</label>
                                <input type="number" id="stepEntry" class="form-control" value="1" min="1" title="Steps per jump">
                            </div>

                            <div class="mb-1 mt-1">
                                <label for="maxSteps" class="form-label mb-0">Max Steps:</label>
                                <input type="number" id="maxSteps" class="form-control" value="1000000" min="1" title="Max steps">
                            </div>

                            <div class="mb-1 mt-1">
                                <label for="delayEntry" class="form-label mb-0">Speed (ms):</label>
                                <input type="number" id="delayEntry" class="form-control" value="300" min="1" title="Step delay (ms)">
                            </div>
                            <p class="medium text-muted mb-2 mt-2">
                                For advanced control, see
                                <a href="#turing_config" class="text-primary fst-italic text-decoration-none">Turing Config</a>.
                            </p>

                            <!-- Control Buttons -->
                            <div class="row mb-1 g-2 mt-auto">
                                <div class="col-4">
                                    <button id="stepBtn" class="btn btn-step w-100 action-btn bi bi-skip-forward-fill">Jump</button>
                                </div>
                                <div class="col-4">
                                    <button id="RunPauseBtn" class="btn btn-runpause w-100 action-btn bi bi-play-fill">Play</button>
                                </div>
                                <div class="col-4">
                                    <button id="resetBtn" class="btn btn-reset w-100 action-btn bi bi-arrow-clockwise">Reset</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Model Results -->
            <div class="card mb-0 mt-0" id = "modelResults">
                <div class="card-header">Model Summary</div>
                <div class="card-body">
                    <div id="results" class="monospace"></div>
                    <div id="resources" class="monospace mt-2"></div>
                </div>
            </div>

            <!-- Help Card -->
            <div class="card" id="helpCard">
                <div class="card-body">
                    <div class="row mb-0 mt-0">
                        <!-- Column 1: Definition -->
                        <div class="col-md-4 mb-4">
                        <h5 class="mb-3">📖 What is a Turing Machine?</h5>

                            <p class="small text-muted">
                            A <dfn>Turing machine</dfn> is an abstract device that models computation by manipulating symbols on a tape. 
                            <a href="https://en.wikipedia.org/wiki/Turing_machine" target="_blank" class="text-decoration-none">
                            Learn more <i class="bi bi-box-arrow-up-right me-1"></i>
                            </a>                            </p>
                            <p class="small text-muted">
                            Each machine has a finite number of states and symbols, fixed at startup. The tape is infinite and is blank where unused.
                            </p>

                            <!-- Formal Definition Section -->
                            <div class="mb-2">
                            <strong>Formal Definition</strong>
                            <p class="small text-muted mb-0">A Turing machine is defined by the tuple:</p>
                            <p class = "mb-0 text-center">
                                <strong>M</strong> = &lang; Q, &Gamma;, b, &Sigma;, &delta;, q<sub>0</sub>, F &rang;
                            </p>
                            <ul class="small text-muted mt-0">
                                <li><strong>Q</strong> – a set of all possible states the machine can be in.</li>
                                <li><strong>Γ</strong> – a set of symbols that can appear on the tape (the tape alphabet).</li>
                                <li><strong>b</strong> – a special blank symbol used to fill the rest of the tape.</li>
                                <li><strong>Σ</strong> – a set of input symbols (a subset of the tape alphabet, but doesn’t include the blank symbol).</li>
                                <li><strong>q<sub>0</sub></strong> – the starting state where the machine begins.</li>
                                <li><strong>F</strong> – a set of final (accepting) states. If the machine stops in one of these, the input is accepted.</li>
                                <li>
                                    <strong>δ (the transition function)</strong> – rules that tell the machine based on current state:
                                    <ul>
                                        <li>what state to move to next,</li>
                                        <li>what symbol to write on the tape, and</li>
                                        <li>whether to move left or right on the tape.</li>
                                    </ul>
                                    If halt state reached, the machine stops.
                                </li>
                            </ul>
                            </div>
                            <p class="small text-muted">
                                For a great introduction, see the <a href="http://plato.stanford.edu/entries/turing-machine" target="_blank">Stanford Encyclopedia of Philosophy entry</a>.
                            </p>
                        </div>

                        <!-- Column 2: Instructions -->
                        <div class="col-md-5 mb-4">
                        <h5 class="mb-3">🛠 Try It Out</h5>
                        <p class="small text-muted">
                            Enter your transition rules and tape input, then control the machine using the buttons below:
                        </p>

                        <h6 class="small text-dark"> Format for Transition Rules</h6>
                        <pre class="bg-light p-1 rounded small">[currentState] [currentSymbol] [newState] [newSymbol] [dir]</pre>

                        <p class="small text-muted mb-2">Example: <code>INIT 0 WRITE 1 R</code></p>

                        <h6 class="small text-dark">Controls</h6>
                        <ul class="small text-muted ps-3 mb-0">
                            <li>
                            <strong>Jump Steps</strong>: Enter the number of steps to skip forward at once.
                            </li>
                            <li>
                            <strong>Max Steps</strong>: Set a limit to how many steps the simulator can execute.
                            </li>
                            <li>
                            <strong>Speed (ms)</strong>: Time delay between automatic steps during playback.
                            </li>
                        </ul>

                        <p class="small text-muted mt-2">
                            Once you've configured your machine and input, use the control buttons:
                            <ul class="small text-muted ps-3">
                            <li><strong>Jump</strong> – Skip ahead by the "Jump Steps" number.</li>
                            <li><strong>Play</strong> – Run continuously until halted or max steps reached.</li>
                            <li><strong>Reset</strong> – Restart from the initial configuration.</li>
                            </ul>
                        </p>
                        </div>

                        <!-- Column 3: Turing Config -->
                        <div class="col-md-3 mb-4">
                        <h5  id="turing_config" class="mb-3">⚙️ Turing Config</h5>
                        <ul class="config-list">
                            <h6 class="mb-2 mt-2">Machine Defaults:</h6>
                            <li class="config-item">
                                <label for="leftSymbolInput" class="me-1 mt-0 mb-0" title="Symbol to represent LEFT move">Left:</label>
                                <input class="config-input text-start" id="leftSymbolInput"
                                type="text" maxlength="1" value="L" style="width: 50px;" />
                            </li>
                            <li class="config-item">
                                <label for="rightSymbolInput" class="me-1 mt-0 mb-0" title="Symbol to represent RIGHT move">Right:</label>
                                <input class="config-input text-start" id="rightSymbolInput"
                                type="text" maxlength="1" value="R" style="width: 50px;" />
                            </li>
                            <li class="config-item">
                                <label for="blankSymbolInput" class="me-1 mt-0 mb-0" title="Symbol to represent empty cells('_'). Avoid /^[+|[+$/g">Blank:</label>
                                <input class="config-input text-start" id="blankSymbolInput"
                                type="text" maxlength="1" value="_" style="width: 50px;" />
                            </li>
                            <li class="config-item">
                                <label for="commentSymbolInput" class="me-2 mt-0 mb-0" title="Symbol to comment out('//')">Comment:</label>
                                <input class="config-input text-start" id="commentSymbolInput"
                                type="text" maxlength="10" value="//" style="width: 50px;" />
                            </li>
                            <li class="config-item">
                                <label for="initStateInput" class="me-1 mt-0 mb-0" title ="State to initialize machine('INIT')">Initial State:</label>
                                <input class="config-input text-start" id="initStateInput"
                                type="text" maxlength="10" value="INIT" style="width: 100px;" />
                            </li>
                            <li class="config-item">
                                <label for="haltStateInput" class="me-1 mt-0 mb-0" title="State to stop machine('HALT')">Halt State:</label>
                                <input class="config-input text-start" id="haltStateInput"
                                type="text" maxlength="10" value="HALT" style="width: 100px;" />
                            </li>
                            <h6 class="mb-0 mt-2"> Machine Limits:</h6>
                            <li class="config-item">
                                <label for="maxStateSizeInput" class="me-1 mt-0 mb-0" title = "Maximum length of any state label (chars)">State Size:</label>
                                <input class="config-input me-1 text-start" id="maxStateSizeInput"
                                type="number" value="32" min="1" max="1000" style="width: 100px;" />
                            </li>
                            <li class="config-item">
                                <label for="maxStatesInput" class="me-1 mt-0 mb-0" title = "Maximum number of states">Total States:</label>
                                <input class="config-input text-start" id="maxStatesInput"
                                type="number" value="1024" min="1" max="1000000" style="width: 100px;" />
                            </li>
                            <li class="config-item">
                                <label for="transitionSizeInput" class="me-1 mt-0 mb-0" title = "Maximum number of transition rules">Total Rules:</label>
                                <input class="config-input text-start" id="transitionSizeInput"
                                type="number" value="710000" min="1" max="1000000" style="width: 100px;" />
                            </li>
                            <li class="config-item">
                                <label for="maxTapeLenInput" class="me-1 mt-0 mb-0" title = "Maximum length of Tape(cells) aka memory">Tape Length:</label>
                                <input class="config-input text-start" id="maxTapeLenInput"
                                type="number" value="1048576" min="1" max="100000000" style="width: 100px;" />
                            </li>
                        </ul>

                        <div class="d-flex justify-content-end mt-2">
                            <button button class="btn btn-reconfigure action-btn w-50 fw-bolder bi bi-gear-fill" onclick="applyConfig()">Re-Configure</button>
                        </div>
                        </div>

                    </div>
                </div>
            </div>
        </div>

        <!-- JavaScript Libraries -->
        <script src="https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.6/ace.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.6/ext-language_tools.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

        <!-- Main Application Script -->
        <script type="module">

            class TuringConfig {
                static LEFT = "L";
                static RIGHT = "R";
                static BLANK = "_";

                static INIT_STATE = "INIT";
                static HALT_STATE = "HALT";
                static COMMENT_PREFIX = "//";

                static MAX_STATES = 1024;
                static MAX_TAPE_LEN = 1048576;
                static MAX_STATE_SIZE = 32;
                static TRANSITION_SIZE = 710000;

                // Optionally add a method to update config from inputs
                static updateFromInputs() {
                    this.LEFT = document.getElementById('leftSymbolInput').value || this.LEFT;
                    this.RIGHT = document.getElementById('rightSymbolInput').value || this.RIGHT;
                    this.BLANK = document.getElementById('blankSymbolInput').value || this.BLANK;
                    this.INIT_STATE = document.getElementById('initStateInput').value || this.INIT_STATE;
                    this.HALT_STATE = document.getElementById('haltStateInput').value || this.HALT_STATE;
                    this.COMMENT_PREFIX = document.getElementById('commentSymbolInput').value || this.COMMENT_PREFIX;

                    this.MAX_STATES = parseInt(document.getElementById('maxStatesInput').value) || this.MAX_STATES;
                    this.MAX_TAPE_LEN = parseInt(document.getElementById('maxTapeLenInput').value) || this.MAX_TAPE_LEN;
                    this.MAX_STATE_SIZE = parseInt(document.getElementById('maxStateSizeInput').value) || this.MAX_STATE_SIZE;
                    this.TRANSITION_SIZE = parseInt(document.getElementById('transitionSizeInput').value) || this.TRANSITION_SIZE;
                }

                static getTimestamp() {
                    return performance.now() / 1000;
                }

                static getCurrentMemoryMB() {
                    return performance.memory ? (performance.memory.usedJSHeapSize / (1024 * 1024)).toFixed(2) : 'N/A';
                }

                parseTransitionRules(transitionRulesStr) {
                    const transitionsList = [];
                    const rawRuleList = transitionRulesStr.split("\n");
                    const comment = TuringConfig.COMMENT_PREFIX
                    for (const rawLine of rawRuleList) {
                        const line = rawLine.trim();
                        if (!line || line.startsWith(comment)) continue;
                        const cleanedLine = line.split(comment)[0].trim();
                        const values = cleanedLine.split(/\s+/).filter(val => val.trim());

                        if (values.length !== 5) {
                            throw new Error(`Invalid transition: "${cleanedLine}". Expected 5 elements, got ${values.length}`);
                        }

                        const [currentState, currentSymbol, newState, newSymbol, direction] = values;
                        if (direction !== TuringConfig.LEFT && direction !== TuringConfig.RIGHT) {
                            throw new Error(`Invalid move direction: '${direction}' in line "${cleanedLine}". Must be '${TuringConfig.LEFT}' or '${TuringConfig.RIGHT}'.`);
                        }

                        for (const [symbol, label] of [[currentSymbol, "current"], [newSymbol, "new"]]) {
                            if (symbol.length !== 1) {
                                throw new Error(`Invalid ${label}_symbol '${symbol}'. Must be a single character.`);
                            }
                        }

                        transitionsList.push([currentState, currentSymbol, newState, newSymbol, direction]);
                    }

                    if (transitionsList.length === 0) {
                        throw new Error("No valid transition rules found.");
                    }

                    if (transitionsList.length > TuringConfig.TRANSITION_SIZE) {
                        throw new Error(`Too many transition rules: ${transitionsList.length}. Maximum allowed rules is ${TuringConfig.TRANSITION_SIZE}.`);
                    }

                    return transitionsList;
                }
            }

            class MachineLogic {
                constructor(
                    transitionsList,
                    initState = TuringConfig.INIT_STATE,
                    haltState = TuringConfig.HALT_STATE,
                    blankSymbol = TuringConfig.BLANK) {
                        this.init_state = initState;
                        this.halt_state = haltState;
                        this.blank_symbol = blankSymbol;

                        this.MAX_STATES = TuringConfig.MAX_STATES;
                        this.MAX_STATE_SIZE = TuringConfig.MAX_STATE_SIZE;

                        this.transitions_list = transitionsList;
                        this.transitions_dict = this._buildTransitionDict(transitionsList, initState, haltState);
                        this.used_tranistions = new Set();

                        // Initialize Tape
                        this.head_position = 0;
                        this.current_state = initState;
                        this.tape = {};
                        this.running = true;
                        this.input_tape = "";
                }

                _validateTransition(transition) {
                    if (transition.length !== 5) {
                        throw new Error(`Invalid transition: ${transition}. Expected 5 elements: (currentState, currentSymbol, newState, newSymbol, moveDirection).`);
                    }

                    const [current_state, current_symbol, new_state, new_symbol, direction] = transition;

                    if (direction !== TuringConfig.LEFT && direction !== TuringConfig.RIGHT) {
                        throw new Error(`Invalid move direction: '${direction}'. Must be '${TuringConfig.LEFT}' or '${TuringConfig.RIGHT}'.`);
                    }

                    for (const [symbol, label] of [[current_symbol, "current"], [new_symbol, "new"]]) {
                        if (symbol.length !== 1) {
                            throw new Error(`Invalid ${label}_symbol: '${symbol}'. Must be a single character.`);
                        }
                    }

                    for (const [state, label] of [[current_state, "current"], [new_state, "new"]]) {
                        if (state.length > this.MAX_STATE_SIZE) {
                            throw new Error(`Invalid ${label}_state: ${state} size=${state.length}. State Size must be less than ${this.MAX_STATE_SIZE} characters.`);
                        }
                    }

                    return transition;
                }

                _buildTransitionDict(transitionsList, initState, haltState) {
                    const transitionDict = {};
                    let hasHaltState = false;


                    for (const transition of transitionsList) {
                        const [currentState, currentSymbol, newState, newSymbol, moveDirection] = this._validateTransition(transition);

                        if (!transitionDict[currentState]) {
                            transitionDict[currentState] = {};
                        }

                        if (currentSymbol in transitionDict[currentState]) {
                            throw new Error(`Duplicate transition for state ${currentState} and symbol ${currentSymbol}`);
                        }

                        transitionDict[currentState][currentSymbol] = [newState, newSymbol, moveDirection];

                        if (newState === haltState) {
                            hasHaltState = true;
                        }
                    }

                    if (Object.keys(transitionDict).length > this.MAX_STATES) {
                        throw new Error(`Too many states: ${Object.keys(transitionDict).length}. Maximum is ${this.MAX_STATES}.`);
                    }

                    if (!transitionDict[initState]) {
                        throw new Error(`Initial state ${initState} not found in the transitions`);
                    }

                    if (!hasHaltState) {
                        throw new Error(`Halt state ${haltState} not found in the transitions`);
                    }

                    return transitionDict;
                }

                _setTape(inputTape) {
                    if (inputTape.includes(" ")) {
                        throw new Error("Input tape must not contain spaces");
                    }

                    this.tape = {};
                    this.input_tape = inputTape;
                    this.headMove = "N";
                    this.head_position = 0;
                    this.current_state = this.init_state;

                    if (inputTape.length > TuringConfig.MAX_TAPE_LEN) {
                        throw new Error(`Input Tape size is : ${inputTape.length}. Maximum tape size allowed is ${TuringConfig.MAX_TAPE_LEN}.`);
                    }

                    for (let i = 0; i < inputTape.length; i++) {
                        const symbol = inputTape[i];
                        if (symbol !== this.blank_symbol) {
                            this.tape[i] = symbol;
                        }
                    }
                }

                _getTapeBoundaries(windowSize = 5) {
                    const positions = Object.keys(this.tape).map(Number);
                    let minPos = positions.length > 0 ? Math.min(...positions) : this.head_position - windowSize;
                    let maxPos = positions.length > 0 ? Math.max(...positions) : this.head_position + windowSize;

                    minPos = Math.min(minPos, this.head_position) - windowSize;
                    maxPos = Math.max(maxPos, this.head_position) + windowSize;
                    return [minPos, maxPos];
                }

                _printTapeState(visualize = true) {
                    const [minPos, maxPos] = this._getTapeBoundaries();
                    const headPosInWindow = this.head_position - minPos;

                    let tapeStr = "";
                    for (let i = minPos; i <= maxPos; i++) {
                        tapeStr += this.tape[i] ?? this.blank_symbol;
                    }

                    const pointerStr = `${" ".repeat(headPosInWindow)}^`;
                    const tape_state = `[${this.stepCount}]: ${this.current_state}`
                    const printedState = [tapeStr, pointerStr, tape_state, ""];

                    if (visualize) {
                        console.log(printedState.join("\n"));
                    }

                    return tapeStr.replace(new RegExp(`^${this.blank_symbol}+|${this.blank_symbol}+$`, 'g'), '');
                }

                _stepLogic() {
                    const stateTransitions = this.transitions_dict[this.current_state];
                    if (!stateTransitions) {
                        throw new Error(`No transitions for state ${this.current_state} with input tape ${this.input_tape}`);
                    }

                    const currentSymbol = this.tape[this.head_position] ?? this.blank_symbol;
                    const transition = stateTransitions[currentSymbol];
                    if (!transition) {
                        throw new Error(`No transition for symbol '${currentSymbol}' in state ${this.current_state} with input tape ${this.input_tape}`);
                    }

                    const [newState, newSymbol, moveDirection] = transition;

                    if (newSymbol === this.blank_symbol) {
                        delete this.tape[this.head_position];
                    } else {
                        this.tape[this.head_position] = newSymbol;
                    }
                    this.used_tranistions.add(this.current_state);
                    const shift = moveDirection === TuringConfig.LEFT ? -1 : 1;
                    this.current_state = newState;
                    this.head_position += shift;
                    this.headMove = moveDirection;
                }

                runLogic(inputTape, maxSteps = 1_000_000, visualize = false) {
                    this.input_tape = inputTape;
                    this._setTape(inputTape);
                    this._printTapeState(visualize);

                    this.stepCount = 0;
                    let tape = "";
                    while (this.running && this.stepCount < maxSteps) {
                        if (this.current_state === this.halt_state) {
                            this.running = false;
                            if (visualize) {
                                console.log(`HALTED after ${this.stepCount} steps`);
                            }
                            continue;
                        }

                        this._stepLogic();
                        tape = this._printTapeState(visualize);
                        this.stepCount++;
                    }

                    return [tape, this.stepCount, this.transitions_list.length];
                }

                async runIncrementally(inputTape, visualize = true, maxSteps = 1_000_000) {
                    console.log("Turing Machine Initialized:");
                    console.log("Enter [space] to step, number to step n times, or q to quit:\n")
                    this.stepCount = 0;
                    let tape = "";

                    this.input_tape = inputTape;
                    this._setTape(inputTape);
                    this._printTapeState(visualize);

                    while (this.running && this.stepCount < maxSteps) {
                        if (this.current_state === this.halt_state) {
                            this.running = false;
                            if (visualize) {
                                console.log(`HALTED after ${this.stepCount} steps`);
                            }
                            break;
                        }
                        const key = await new Promise(resolve => {
                            process.stdin.resume();
                            process.stdin.setEncoding('utf8');
                            process.stdin.once('data', data => resolve(data.trim()));
                        });

                        if (key === 'q') {
                            console.log("Machine Stopped Manually");
                            break;
                        } else if (key === '' || key === ' ') {
                            this._stepLogic();
                            this.stepCount++;
                            tape = this._printTapeState(visualize);
                        } else if (/^\d+$/.test(key)) {
                            const stepsToRun = parseInt(key, 10);
                            for (let i = 0; i < stepsToRun; i++) {
                                if (this.current_state === this.halt_state || !this.running) break;
                                this._stepLogic();
                                this.stepCount++;
                                tape = this._printTapeState(visualize);
                            }
                        } else {
                            console.log(`Unrecognized key: '${key}'`);
                        }
                    }

                    return [tape, this.stepCount, this.transitions_list.length];
                }

            }

            class StateManager {
                constructor(guiInstance, getRulesText, setRulesText) {
                    this.gui = guiInstance; // Store the whole Simulator_GUI object
                    this.getRulesText = getRulesText;
                    this.setRulesText = setRulesText;
                }

                getCPU() {
                    return this.gui.cpu;
                }

                setCPU(cpu) {
                    this.gui.cpu = cpu;
                }

                copyText(source, label) {
                    const text = (typeof source === "string") 
                        ? source 
                        : source.value || source.textContent || "";

                    if (!text.trim()) {
                        alert(`No ${label} to copy`);
                        return;
                    }

                    navigator.clipboard.writeText(text)
                        .then(() => alert(`${label} copied to clipboard`))
                        .catch(err => {
                            console.error(`Failed to copy ${label}:`, err);
                            alert(`Failed to copy ${label}. Please try again.`);
                        });
                }

                clearText(target, label, setter = null) {
                    if (confirm(`Clear ${label}?`)) {
                        if (setter) {
                            setter("");
                        } else if (typeof target === "string") {
                            document.getElementById(target).value = "";
                        } else if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {
                            target.value = "";
                        }
                    }
                }

                async loadStateFromPath(filePath) {
                    try {
                        // Fetch the JSON file
                        const response = await fetch(filePath);
                        if (!response.ok) throw new Error(`Failed to fetch: ${response.status}`);

                        // Convert to JSON
                        const jsonData = await response.json();

                        // Create a File object that loadState expects
                        const jsonBlob = new Blob([JSON.stringify(jsonData)], {type: 'application/json'});
                        const jsonFile = new File([jsonBlob], filePath.split('/').pop());

                        // Call your existing loadState
                        return jsonFile;
                    } catch (error) {
                        console.error('Error loading template:', error);
                        this.updateMachineStatus(`Template load failed: ${error.message}`, "text-danger");
                        throw error;
                    }
                }

                saveState() {
                    const {
                        LEFT, RIGHT, BLANK, INIT_STATE, HALT_STATE, COMMENT_PREFIX,
                        MAX_STATES, MAX_TAPE_LEN, MAX_STATE_SIZE, TRANSITION_SIZE
                    } = TuringConfig;

                    const cpu = this.getCPU();
                    const cpuState = cpu ? {
                        head_position: cpu.head_position,
                        current_state: cpu.current_state,
                        input_tape: cpu.input_tape,
                        running: cpu.running,
                        tape: cpu.tape
                    } : {};

                    return {
                        name: this.gui.modelName,
                        rulesText: this.getRulesText(),
                        initial_tape: this.gui.initial_tape,
                        rulesNo: this.gui.rulesNo,
                        max_len: this.gui.max_len,
                        tape_len: this.gui.tape_len,
                        step_count: this.gui.step_count,
                        LEFT, RIGHT, BLANK, INIT_STATE, HALT_STATE, COMMENT_PREFIX,
                        MAX_STATES, MAX_TAPE_LEN, MAX_STATE_SIZE, TRANSITION_SIZE,
                        history: this.gui.history,
                        ...cpuState,
                        buildGIF:  document.getElementById("buildGIF").disabled,
                        stepBtn: document.getElementById("stepBtn").disabled,
                        RunPauseBtn:  document.getElementById("RunPauseBtn").disabled,
                        ControlBtn:  document.getElementById("ControlBtn").className,
                    };
                }

                async loadJSON(file) {
                    return new Promise((resolve, reject) => {
                        if (!file) {
                            reject(new Error("No file provided"));
                            return;
                        }

                        const reader = new FileReader();

                        reader.onload = (e) => {
                            try {
                                const json = JSON.parse(e.target.result);
                                if (!json || typeof json !== "object") {
                                    throw new Error("Invalid file format");
                                }
                                resolve(json); // ✅ return the JSON to the caller
                            } catch (error) {
                                console.error("Error loading state file:", error);
                                alert(`Error loading file: ${error.message}`);
                                reject(error);
                            }
                        };

                        reader.onerror = () => {
                            reject(new Error("Error reading file"));
                        };

                        reader.readAsText(file);
                    });
                }

                async loadJSONLines(file) {
                    if (!file) {
                        throw new Error("No file provided");
                    }

                    const text = await file.text();
                    const lines = text.split('\n').filter(line => line.trim());

                    if (lines.length === 0) {
                        throw new Error("File is empty");
                    }

                    // 1. Parse metadata (first line)
                    let state;
                    try {
                        state = JSON.parse(lines[0]);
                    } catch (error) {
                        throw new Error(`Invalid metadata (line 1): ${error.message}`);
                    }

                    // 2. Parse history entries (remaining lines)
                    if (lines.length > 1) {
                        state.history = [];
                        for (let i = 1; i < lines.length; i++) {
                            try {
                                const entry = JSON.parse(lines[i]);
                                state.history.push(entry);
                            } catch (error) {
                                console.warn(`Skipping invalid history entry (line ${i + 1})`, error);
                                // Optionally: Continue or throw an error
                            }
                        }
                    }

                    // 3. Validate critical fields (customize as needed)
                    const requiredFields = ["INIT_STATE", "HALT_STATE", "tape", "current_state"];
                    for (const field of requiredFields) {
                        if (state[field] === undefined) {
                            throw new Error(`Missing required field: ${field}`);
                        }
                    }

                    return state;
                }

                loadRules(file) {
                    return new Promise((resolve, reject) => {
                        if (!file) {
                            reject("No file provided");
                            return;
                        }

                        const reader = new FileReader();
                        reader.onload = (e) => {
                            try {
                                const text = e.target.result.trim();
                                resolve(text); // resolves with the file text
                            } catch (error) {
                                reject(error);
                            }
                        };
                        reader.onerror = reject;

                        reader.readAsText(file);
                    });
                }

                async loadYAML(file) {
                    return new Promise((resolve, reject) => {
                        if (!file) {
                            reject(new Error("No file provided"));
                            return;
                        }

                        const reader = new FileReader();

                        reader.onload = (e) => {
                            try {
                                // Reverse of dump() — parse YAML text into object
                                const state = jsyaml.load(e.target.result);

                                if (!state || typeof state !== "object") {
                                    throw new Error("Invalid YAML format");
                                }

                                resolve(state); // Let caller decide how to handle it (e.g., this.loadState(state))
                            } catch (error) {
                                console.error("Error parsing YAML:", error);
                                alert(`Error loading YAML file: ${error.message}`);
                                reject(error);
                            }
                        };

                        reader.onerror = () => {
                            reject(new Error("Error reading YAML file"));
                        };

                        reader.readAsText(file);
                    });
                }

                exportFileData(format) {
                    let file_data = "";
                    switch (format) {
                        case "txt":
                            file_data = this.getRulesText();
                            break;

                        case "json":
                            file_data = JSON.stringify(this.saveState(), null, 2);
                            break;

                        case "jsonl":
                            const json_data = this.saveState();
                            const { history, ...metadata } = json_data;
                            const lines = [JSON.stringify(metadata)];
                            if (history?.length) {
                                history.forEach(entry => lines.push(JSON.stringify(entry)));
                            }
                            file_data = lines.join("\n");
                            break;

                        case "yaml":
                            file_data = jsyaml.dump(this.saveState());
                            break;

                        default:
                            console.warn("Unknown export format selected");
                    }
                    return file_data;
                }

                downloadFile(file_data, file_type) {
                    return new Promise((resolve, reject) => {
                        let mimeType;
                        switch (file_type) {
                            case "json":
                                mimeType = "application/json";
                                break;
                            case "jsonl":
                                mimeType = "application/x-ndjson"; // standard for JSON Lines
                                break;
                            case "txt":
                                mimeType = "text/plain";
                                break;
                            case "yaml":
                                mimeType = "text/yaml";
                                break;
                            default:
                                reject(new Error(`Unsupported file type: ${file_type}`));
                                return;
                        }

                        const blob = new Blob([file_data], { type: mimeType });
                        const url = URL.createObjectURL(blob);

                        const a = document.createElement("a");
                        a.href = url;
                        a.download = `${this.gui.modelName}.${file_type}`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);

                        URL.revokeObjectURL(url);
                        resolve();
                    });
                }

            }

            class GIFBuilder {
                constructor(tapeDisplay, progressElement, gifName, rulesNo, max_len) {
                    this.validateElements(tapeDisplay, progressElement, gifName);

                    this.tapeDisplay = tapeDisplay;
                    this.progressElement = progressElement;
                    this.isBuilding = false;
                    this.gif = null;
                    this.gifName = gifName ?? 'Unnamed';
                    this.rulesNo = rulesNo ?? 0;
                    this.max_len = max_len ?? 0;
                    this._initialTapeString = '';
                    this.frameBgColor = "#ffffff";
                    this.textColor = "#1b1b1b";

                    this.initTempContainer();
                }

                validateElements(...elements) {
                    elements.forEach(el => {
                        if (!el) throw new Error('Required DOM elements not found');
                    });
                }

                initTempContainer() {
                    this.tempContainer = document.createElement('div');
                    Object.assign(this.tempContainer.style, {
                        position: 'fixed',
                        left: '-9999px',
                        top: '0',
                        zIndex: '9999'
                    });
                    document.body.appendChild(this.tempContainer);
                }

                _initGIF() {
                    this.CELL_WIDTH = 50;
                    this.GIF_HEIGHT = 200;
                    this.GIF_WIDTH = this.VISIBLE_CELLS * this.CELL_WIDTH;
                    this.midpoint = Math.floor(this.VISIBLE_CELLS / 2) - 1;

                    this.gif = new GIF({
                        workers:  Math.min(navigator.hardwareConcurrency || 4, 8),
                        quality: 10, // Increased quality (1-10)
                        width: this.GIF_WIDTH * this.RESOLUTION_SCALE, // Render at higher resolution
                        height: this.GIF_HEIGHT * this.RESOLUTION_SCALE, // Render at higher resolution
                        workerScript: './pkg_backups/gif.worker.js',
                        dither: false, // Disable dithering for sharper images
                        transparent: null, // No transparency
                        background: this.frameBgColor
                    });
                }

                async buildFromHistory(history, seekCallback) {
                    if (this.isBuilding) throw new Error("GIF generation already in progress");
                    if (!Array.isArray(history) || history.length < 2) {
                        throw new Error("Not enough history to generate GIF");
                    }
                    this.gifColor = document.getElementById('gifColor').value;
                    this.VISIBLE_CELLS = ((parseInt(document.getElementById('visibleCells').value) || 15) | 1);
                    this.RESOLUTION_SCALE = (parseInt(document.getElementById('resolution').value))

                    this.isBuilding = true;
                    this.setupUI();

                    try {
                        this._initGIF();
                        await this._processFrames(history, seekCallback);
                        return await this._finalizeGIF();
                    } catch (error) {
                        this.handleBuildError(error);
                        throw error;
                    }
                }

                setupUI() {
                    this.progressElement.textContent = 'Preparing GIF...';
                    document.getElementById('gifCard').style.display = 'block';
                }

                async _processFrames(history, seekCallback) {
                    const frameDelay = parseInt(document.getElementById('gifSpeed').value);
                    const holdCount = 3;
                    const lastIndex = history.length - 1;

                    // Process hold frames
                    await this.processHoldFrames(0, holdCount, history, seekCallback, frameDelay);

                    // Process main frames
                    await this.processMainFrames(history, seekCallback, frameDelay);

                    // Process end hold frames
                    await this.processHoldFrames(lastIndex, holdCount, history, seekCallback, frameDelay);
                }

                async processHoldFrames(frameIndex, count, history, seekCallback, frameDelay) {
                    for (let j = 0; j < count; j++) {
                        await this.processSingleFrame(
                            frameIndex,
                            history,
                            frameDelay,
                            seekCallback,
                            this.updateProgress(count, history.length)
                        );
                    }
                }

                async processMainFrames(history, seekCallback, frameDelay) {
                    const batchSize = Math.floor(history.length / 10);
                    for (let i = 0; i < history.length; i++) {
                        if (i % batchSize === 0) {
                            this.updateProgress(i, history.length);
                            await this.yieldToUI();
                        }
                        await this.processSingleFrame(i, history, frameDelay, seekCallback);
                    }
                }

                async processSingleFrame(frameIndex, history, frameDelay, seekCallback, progressText = '') {
                    if (!this.isBuilding) throw new Error("GIF generation cancelled");
                    if (progressText) this.progressElement.textContent = progressText;

                    seekCallback(frameIndex);
                    const frame = this._renderFrame(history[frameIndex], frameIndex);

                    // Improved frame handling
                    this.tempContainer.innerHTML = '';
                    this.tempContainer.appendChild(frame);

                    // Add slight delay for DOM stabilization
                    await new Promise(resolve => setTimeout(resolve, 50));

                    // Clone the node to avoid iframe issues
                    const clone = frame.cloneNode(true);
                    const canvas = await this.captureFrame(clone);
                    this.gif.addFrame(canvas, { delay: frameDelay, copy: true });

                    // Clean up
                    clone.remove();
                }

                async captureFrame(element) {
                    // Create a clean container for capture
                    const captureContainer = document.createElement('div');
                    captureContainer.style.position = 'absolute';
                    captureContainer.style.left = '-9999px';
                    captureContainer.appendChild(element.cloneNode(true));
                    document.body.appendChild(captureContainer);
                    
                    try {
                        return await html2canvas(captureContainer.firstChild, {
                            backgroundColor: this.frameBgColor,
                            scale: this.RESOLUTION_SCALE,
                            useCORS: true,
                            allowTaint: false, // Changed to false to prevent taint warnings
                            width: this.GIF_WIDTH,
                            height: this.GIF_HEIGHT,
                            logging: false,
                            removeContainer: true, // Let html2canvas handle cleanup
                            onclone: (clonedDoc) => {
                                // Remove any problematic elements from the clone
                                clonedDoc.querySelectorAll('iframe, script').forEach(el => el.remove());
                            }
                        });
                    } finally {
                        // Ensure cleanup
                        captureContainer.remove();
                    }
                }

                updateProgress(current, total) {
                    const percent = Math.round(((current + 1) / total) * 100);
                    this.progressElement.textContent = `Processed ${percent}% of Steps`;
                }

                async yieldToUI(delay = 0) {
                    await new Promise(resolve => setTimeout(resolve, delay));
                }

                _renderFrame(stateSnapshot, stepIndex) {
                    const { head, tape, state, move: headMove } = stateSnapshot;
                    const container = this.createFrameContainer();

                    // Add GIF Header
                    container.appendChild(this.createHeader(tape));

                    // Add tape display
                    container.appendChild(this.createTapeDisplay(head, tape));

                    // Add status display
                    container.appendChild(this.createStatusDisplay(stepIndex, state, headMove, head));

                    // Add tape summary
                    if (stepIndex === 0) this._initialTapeString = this._tapeToString(tape);
                    container.appendChild(this.createTapeSummary(tape));

                    return container;
                }

                createFrameContainer() {
                    const container = document.createElement('div');
                    Object.assign(container.style, {
                        position: 'relative',
                        width: `${this.GIF_WIDTH}px`, // Original display size
                        height: `${this.GIF_HEIGHT}px`, // Original display size
                        backgroundColor: this.frameBgColor,
                        padding: '20px',
                        boxSizing: 'border-box',
                        fontFamily: 'monospace',
                        color: '#333',
                        fontSize: '14px', // Original font size
                        lineHeight: '20px' // Original line height
                    });
                    return container;
                }

                createHeader() {
                    const header = document.createElement('div');
                    Object.assign(header.style, {
                        zIndex: 10,
                        display: 'flex',
                        top: '1px',
                        left: '20px',
                        right: '20px',
                        height: '28px',
                        fontSize: '12px',
                        padding:  '4px 6px',
                        position: 'absolute',
                        alignItems: 'center',
                        fontFamily: 'monospace',
                        boxSizing: 'border-box',
                        justifyContent: 'space-between',
                        color: this.textColor,
                        backgroundColor: this.frameBgColor,
                    });

                    const left = document.createElement('span');
                    left.textContent = `Rules Count: ${this.rulesNo} | Max Tape Size: ${this.max_len}`;

                    const right = document.createElement('span');
                    right.textContent = `${this.gifName}`;
                    right.style.fontStyle = "italic";

                    header.appendChild(left);
                    header.appendChild(right);

                    return header;
                }

                createTapeDisplay(head, tape) {
                    const tapeWrapper = document.createElement('div');
                    tapeWrapper.className = 'tape-wrapper';
                    Object.assign(tapeWrapper.style, {
                        paddingTop: '8px',
                        paddingBottom: '1px',
                    });

                    const tapeContainer = document.createElement('div');
                    tapeContainer.className = 'tape-container';

                    for (let i = head - this.midpoint; i < head + this.midpoint + 2; i++) {
                        const cell = document.createElement('div');
                        cell.className = 'tape-cell' + (i === head ? ' active' : '');

                        if (i === head) {
                            cell.style.borderColor = this.gifColor; // e.g. '#f00' or from config
                        }
                        cell.textContent = tape[i] ?? TuringConfig.BLANK;

                        tapeContainer.appendChild(cell);
                    }

                    tapeWrapper.appendChild(tapeContainer);
                    return tapeWrapper;
                }

                createStatusDisplay(stepIndex, state, headMove, head) {
                    const statusContainer = document.createElement('div');
                    Object.assign(statusContainer.style, {
                        position: 'absolute',
                        top: '95px', // Original position
                        left: `${(this.midpoint)}px`, // Original position
                        textAlign: 'center',
                        lineHeight: '1.5',
                        fontSize: '15px', // Original font size
                        width: '100%',
                        color: this.textColor
                    });

                    const arrowStyle = `font-size: 40px; vertical-align: middle;`; // Original size

                    const leftArrow = `<span style="color: ${headMove ===  TuringConfig.LEFT ? this.gifColor : this.textColor}; ${arrowStyle}">←</span>`;
                    const rightArrow = `<span style="color: ${headMove === TuringConfig.RIGHT ? this.gifColor : this.textColor}; ${arrowStyle}">→</span>`;

                    const stateDisplay = document.createElement('div');
                    stateDisplay.style.fontSize = '15px'; // Original size
                    stateDisplay.style.fontWeight = 'bold';
                    stateDisplay.innerHTML = `${leftArrow} (STEP [${stepIndex}]: ${state}) ${rightArrow}`;

                    statusContainer.appendChild(stateDisplay);
                    return statusContainer;
                }

                createTapeSummary(tape) {
                    const summary = document.createElement('div');
                    Object.assign(summary.style, {
                        position: 'absolute',
                        top: '140px',
                        left: '20px',
                        fontSize: '12px',
                        lineHeight: '1.7',
                        color: this.textColor
                    });

                    const currentLabel = document.createElement('div');
                    currentLabel.textContent = `   Full Tape: ${this._tapeToString(tape)}`;
                    currentLabel.style.whiteSpace = 'pre';

                    const initialLabel = document.createElement('div');
                    initialLabel.textContent = `Initial Tape: ${this._initialTapeString}`;
                    currentLabel.style.whiteSpace = 'pre';

                    summary.appendChild(initialLabel);
                    summary.appendChild(currentLabel);
                    return summary;
                }

                _tapeToString(tape) {
                    const keys = Object.keys(tape).map(Number);
                    if (keys.length === 0) return '';

                    const min = Math.min(...keys);
                    const max = Math.max(...keys);
                    let result = '';

                    for (let i = min; i <= max; i++) {
                        result += tape[i] ?? '_';
                    }
                    return result;
                }

                async _finalizeGIF() {
                    return new Promise((resolve, reject) => {
                        this.progressElement.textContent = `GIF Rendering... This may take a while`;
                        this.gif.on('abort', () => reject(new Error("GIF generation aborted")));
                        this.gif.on('error', e => reject(e));
                        this.gif.render();
                        this.gif.on('finished', blob => this.handleGIFComplete(blob, resolve));
                    });
                }

                handleGIFComplete(blob, resolve) {
                    const url = URL.createObjectURL(blob);
                    this.progressElement.textContent = `GIF Rendered`;
                    const gifview = document.getElementById('gifContainer')
                    gifview.style.display = "block";

                    // Set preview image
                    const preview = document.getElementById('gifPreview');
                    preview.src = url;

                    // Set download link
                    const downloadLink = document.getElementById('downloadGIF');
                    downloadLink.href = url;
                    downloadLink.download = `${this.gifName}.gif`;

                    this.isBuilding = false;
                    resolve(blob);
                }

                handleBuildError(error) {
                    this.isBuilding = false;
                    this.progressElement.textContent = 'Error generating GIF';
                    console.error('GIF generation error:', error);
                }

                cancel() {
                    document.getElementById('gifCard').style.display = 'none';
                    if (confirm("Are you sure you want to cancel generation of GIF?")) {
                        if (this.isBuilding && this.gif) {
                            this.gif.abort();
                            this.isBuilding = false;
                            this.progressElement.textContent = 'GIF generation cancelled';
                        }
                    }
                }

            }

            class Simulator_GUI {
                docIDs = [
                    // Core Controls
                    'stepBtn', 'RunPauseBtn', 'resetBtn', 'ControlBtn',
                    // Navigation & Step Management
                    'gotoBtn', 'gotoStep', 'stepEntry', 'maxSteps', 'historySlider',
                    // Tape & Input Handling
                    'tapeInput', 'tapeDisplay', 'clearTapeBtn', 'copyTapeBtn',
                    // Rules & Configuration
                    'rulesText', 'clearRulesBtn', 'copyRulesBtn', 'modelInputName',
                    // Status & Feedback
                    'stepState', 'machineStatus', 'results', 'resources',
                    // GIF Export
                    'buildGIF', 'generateGIF', 'cancelGIF', 'gifCard', 'gifContainer', 'gifPreview', 'GIFStatus',
                    // File Operations
                    'importModal', 'exportModal','importBtn', 'exportBtn', 'saveBtn',
                    // Performance
                    'delayEntry'
                ];

                EXAMPLES = {
                        'unary_increment': 'unary_increment.json',
                        'unary_decrement': 'unary_decrement.json',
                        // 'Binary Adder': 'binary_adder.json',
                        // 'Busy Beaver (3-state)': 'busy_beaver.json'
                    };

                constructor() {
                    this.init_time = TuringConfig.getTimestamp();
                    this.auto_run_timeout = null;
                    this.running = false;
                    this.modelName = " ";
                    this.step_count = 0;
                    this.MAX_STEPS = 0;
                    this.BASE_STEP = 0;
                    this.history = [];
                    this.DELAY = 0;

                    this.initElements();
                    this.setupEventListeners();
                    this.setupModalHandlers();
                    this.setupDropdown()

                    this.stateManager = new StateManager(
                        this, window.getRulesText, window.setRulesText,
                    );
                }

                initElements() {
                    for (const id of this.docIDs) {
                        this[id] = document.getElementById(id);
                    }
                }

                delElements() {
                    this.docIDs.forEach(id => {
                        const elem = document.getElementById(id);
                        if (elem) {
                            const newElem = elem.cloneNode(true);
                            elem.parentNode.replaceChild(newElem, elem);
                        }
                    });
                }

                setupEventListeners() {
                    const withScrollToTop = (callback) => {
                        return (...args) => {
                            callback(...args);
                            window.scrollTo({ top: 0, behavior: 'smooth' });
                        };
                    };

                    this.modelInputName.addEventListener('input', () => {
                        this.modelName = this.modelInputName.value.trim() || "turing_test";
                    });

                    // Navigation and step controls
                    this.resetBtn.addEventListener('click', withScrollToTop(() => this.reset()));
                    this.gotoBtn.addEventListener('click', withScrollToTop(() => this.goToStep()));
                    this.stepBtn.addEventListener('click', withScrollToTop(() => this.step()));
                    this.historySlider.addEventListener('input', withScrollToTop(() =>
                        this.seekHistory(parseInt(this.historySlider.value))
                    ));

                    // Run/Pause logic
                    this.RunPauseBtn.addEventListener('click', withScrollToTop(() => this.ControlBtn.click()));
                    this.ControlBtn.addEventListener('click', () => {
                        if (this.running) {
                            this.pause();
                        } else if (this.cpu?.current_state === this.cpu?.halt_state) {
                            this.reset();
                        } else {
                            this.run();
                        }
                    });
                    this.updateControlButton('run');

                    // Show GIF card
                    this.buildGIF.addEventListener("click", () => {
                        if (this.history?.length >= 2) {
                            this.gifCard.style.display = "block";
                        } else {
                            alert("Not enough history to generate a GIF. Please run the machine first.");
                        }
                    });

                    // Generate GIF from captured frames
                    this.generateGIF.addEventListener("click", () => this.generateGIFFromHistory());

                    this.cancelGIF.addEventListener("click", () => {
                        if (this.gifBuilder.isBuilding){
                            this.gifBuilder.cancel()
                            this.setAllButtonsDisabled(false)
                        }
                    });

                    // Copy & Clear buttons setup
                    this.copyRulesBtn.addEventListener('click', () => {
                        this.stateManager.copyText(window.getRulesText(), "Transition rules");
                    });

                    this.clearRulesBtn.addEventListener('click', () => {
                        this.stateManager.clearText(null, "all transition rules", window.setRulesText.bind(this));
                    });

                    this.copyTapeBtn.addEventListener('click', () => {
                        this.stateManager.copyText(this.tapeInput, "Initial Tape");
                    });

                    this.clearTapeBtn.addEventListener('click', () => {
                        this.stateManager.clearText("tapeInput", "initial Tape");
                    });

                    // Import and Exports
                    this.importBtn.addEventListener("click", () => this.handleImports());
                    this.exportBtn.addEventListener("click", () => this.handleExports());
                }

                toggleModal(modalElement, show) {
                    if (!modalElement) return;
                    modalElement.classList.toggle('active', show);
                    document.body.style.overflow = show ? 'hidden' : '';
                }

                setupModalHandlers() {

                    this.importBtn?.addEventListener('click', () => this.toggleModal(this.importModal, true));
                    this.exportBtn?.addEventListener('click', () => this.toggleModal(this.exportModal, true));

                    // Shared close handler
                    const closeAllModals = () => {
                        this.toggleModal(this.importModal, false);
                        this.toggleModal(this.exportModal, false);
                    };

                    // Close buttons and backdrop
                    document.querySelectorAll('.tm-modal-close').forEach(btn => {
                        btn.addEventListener('click', closeAllModals);
                    });

                    // Backdrop click
                    [this.importModal, this.exportModal].forEach(modal => {
                        modal?.addEventListener('click', (e) => {
                            if (e.target === modal) closeAllModals();
                        });
                    });

                }

                setupDropdown() {
                    document.addEventListener('DOMContentLoaded', () => {
                        const examplesMenu = document.getElementById('examplesMenu');
                        examplesMenu.innerHTML = '';

                        // Add examples to dropdown
                        Object.entries(this.EXAMPLES).forEach(([displayName, filename]) => {
                            const li = document.createElement('li');
                            li.innerHTML = `
                                <a class="dropdown-item fst-italic" href="#" data-example="${filename}">
                                    ${displayName}
                                </a>
                            `;
                            li.addEventListener('click', () => this.loadExample(displayName));
                            examplesMenu.appendChild(li);
                        });

                        // Add divider and blank option
                        examplesMenu.appendChild(document.createElement('hr')).classList.add('dropdown-divider', 'm-0');

                        const blankLi = document.createElement('li');
                        blankLi.innerHTML = `
                            <a class="dropdown-item fst-italic" href="#" data-example="empty">
                                Blank Machine
                            </a>
                        `;
                        blankLi.addEventListener('click', () => this.resetToBlankMachine());
                        examplesMenu.appendChild(blankLi);
                    });
                }

                async loadExample(displayName) {
                    try {
                        const filename = this.EXAMPLES[displayName]
                        const response = await fetch(`../example_files/${filename}`);
                        if (!response.ok) throw new Error('File not found');

                        const exampleConfig = await response.json();
                        this.loadState(exampleConfig);

                        // Update UI
                        document.querySelector('#examplesDropdown').textContent = displayName;
                        document.getElementById('modelInputName').value = displayName;
                        this.updateMachineStatus(`'${displayName}' Loaded`, "text-secondary");
                        this.modelName = displayName;
                    } catch (error) {
                        console.error('Error loading example:', error);
                        alert(`Failed to load example: ${filename}\n${error.message}`);
                    }
                }

                resetToBlankMachine() {
                    document.querySelector('#examplesDropdown').textContent = 'Select example...';
                    document.getElementById('modelInputName').value = '';
                    this.tapeInput.value = "",
                    this.reset()
                    this.rulesNo = 0;
                    this.modelName = "";
                    window.setRulesText("")
                    this.updateMachineStatus(`Empty Model Created`, "text-secondary");

                }

                handleImports() {
                    const fileInput = document.getElementById('fileInput');
                    const previewElement = document.getElementById("importPreview");
                    const importConfirmBtn = document.getElementById('importConfirmBtn');
                    const filePreviewContainer = document.getElementById('filePreviewContainer');
                    const exportClose = document.getElementById('closeImport');

                    let selectedFile = null;
                    let loadedFileType = '';
                    let file_data = '';

                    function clearFilePreview() {
                        filePreviewContainer.innerHTML = '';
                        selectedFile = null;
                        loadedFileType = '';
                        previewElement.value = ''
                        importConfirmBtn.disabled = true;
                    }

                    function showFilePreview(file) {
                        const chip = document.createElement('div');
                        chip.className = 'tm-file-preview-chip';

                        const fileNameSpan = document.createElement('span');
                        fileNameSpan.textContent = file.name;

                        const removeBtn = document.createElement('button');
                        removeBtn.type = 'button';
                        removeBtn.innerHTML = '&times;';
                        removeBtn.title = 'Remove file';

                        removeBtn.addEventListener('click', () => {
                            clearFilePreview();
                            fileInput.value = '';
                        });

                        chip.appendChild(fileNameSpan);
                        chip.appendChild(removeBtn);

                        filePreviewContainer.appendChild(chip);

                        importConfirmBtn.disabled = false;
                    }

                    function handleFiles(files) {
                        if (!files.length) return;

                        if (files.length >= 2)
                            alert("Multiple files selected. Select a single file model");

                        const file = files[0];
                        const allowedExts = ['json', 'jsonl', 'yaml', 'txt'];
                        const ext = file.name.split('.').pop().toLowerCase();

                        if (!allowedExts.includes(ext)) {
                            alert('Unsupported file type');
                            clearFilePreview();
                            return;
                        }
                        clearFilePreview();

                        selectedFile = file;
                        loadedFileType = ext;

                        showFilePreview(file);
                        return selectedFile;
                    }

                    // Option card click opens file dialog with appropriate accept attribute
                    document.querySelectorAll('.tm-option-card').forEach(card => {
                        card.addEventListener('click', () => {
                            fileInput.accept = `.${card.dataset.type}`;
                            fileInput.click();
                        });
                    });

                    // Drag and drop zone setup
                    const dropzone = document.querySelector('.tm-file-dropzone');
                    if (dropzone) {
                        dropzone.addEventListener('click', () => fileInput.click());

                        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(e =>
                            dropzone.addEventListener(e, preventDefaults, false)
                        );

                        ['dragenter', 'dragover'].forEach(e =>
                            dropzone.addEventListener(e, () => dropzone.classList.add('highlight'), false)
                        );

                        ['dragleave', 'drop'].forEach(e =>
                            dropzone.addEventListener(e, () => dropzone.classList.remove('highlight'), false)
                        );

                        dropzone.addEventListener('drop', (e) => handleFiles(e.dataTransfer.files), false);

                        function preventDefaults(e) {
                            e.preventDefault();
                            e.stopPropagation();
                        }
                    }

                    // File input change event triggers handleFiles
                    fileInput.addEventListener('change', async (e) => {
                        selectedFile = handleFiles(e.target.files);
                        e.target.value = '';
                        if (loadedFileType === 'json') {
                            file_data = await this.stateManager.loadJSON(selectedFile);
                            previewElement.value = JSON.stringify(file_data, null, 2);
                        } else if (loadedFileType === 'jsonl') {
                            file_data = await this.stateManager.loadJSONLines(selectedFile);
                            previewElement.value = JSON.stringify(file_data, null, 2);
                        } else if (loadedFileType === 'yaml') {
                            file_data = await this.stateManager.loadYAML(selectedFile);
                            previewElement.value = jsyaml.dump(file_data);
                        } else if (loadedFileType === 'txt') {
                            file_data = await this.stateManager.loadRules(selectedFile);
                            previewElement.value = file_data;
                        } else {
                            throw new Error('Unsupported file type');
                        }
                    });

                    // Import button click event
                    importConfirmBtn.addEventListener('click', async () => {
                        if (!selectedFile) {
                            alert('No file selected');
                            return;
                        }

                        const file_name = selectedFile.name.replace(/\.[^/.]+$/, '');
                        document.getElementById('modelInputName').value = file_name;
                        this.modelName = file_name;

                        if (loadedFileType === 'txt') {
                            window.setRulesText(file_data);
                        } else {
                            this.loadState(file_data);
                        }
                        this.updateMachineStatus(`'${file_name}' loaded`, "text-success");
                    });

                    // Close buttons and backdrop
                    exportClose.addEventListener("click", () => {
                        clearFilePreview();
                    });
                }

                loadState(file_data) {
                    // Restore configuration inputs with defaults
                    const configMap = {
                        LEFT:           ['leftSymbolInput',  'L'],
                        RIGHT:          ['rightSymbolInput', 'R'],
                        BLANK:          ['blankSymbolInput', '_'],
                        INIT_STATE:     ['initStateInput', 'INIT'],
                        HALT_STATE:     ['haltStateInput', 'HALT'],
                        COMMENT_PREFIX: ['commentSymbolInput', '//'],
                        MAX_STATES:     ['maxStatesInput', 1024],
                        MAX_STATE_SIZE: ['maxStateSizeInput', 32],
                        MAX_TAPE_LEN:   ['maxTapeLenInput', 1048576],
                        TRANSITION_SIZE:['transitionSizeInput', 710000]
                    };

                    Object.entries(configMap).forEach(([key, [elementId, defaultVal]]) => {
                        const value = (file_data[key] !== undefined && file_data[key] !== '')
                            ? file_data[key]
                            : defaultVal;
                        document.getElementById(elementId).value = value;
                    });

                    TuringConfig.updateFromInputs();

                    // Restore CPU state
                    const cpuDefaults = {
                        tape: [],
                        input_tape: '',
                        running: false,
                        head_position: 0,
                        current_state: '',
                    };

                    // Restore transition rules separately
                    const rulesText = file_data.rulesText || '';
                    window.setRulesText(rulesText);
                    const transitions_list = new TuringConfig().parseTransitionRules(file_data.rulesText);
                    const new_cpu = new MachineLogic(transitions_list, file_data.INIT_STATE, file_data.HALT_STATE);
                    this.cpu = new_cpu;

                    Object.keys(cpuDefaults).forEach(key => {
                        this.cpu[key] = file_data[key] ?? cpuDefaults[key];
                    });

                    // Restore UI state
                    const uiDefaults = {
                        rulesNo: 0,
                        max_len: 0,
                        tape_len: 0,
                        history: [],
                        step_count: 0,
                        initial_tape: '',
                        running: false,
                    };

                    Object.keys(uiDefaults).forEach(key => {
                        this[key] = file_data[key] ?? uiDefaults[key];
                    });

                    // Update UI elements
                    if (this.tapeInput) this.tapeInput.value = this.initial_tape;

                    // Update control button
                    if (file_data.ControlBtn?.split(" ").includes("btn-reset")) {
                        this.updateControlButton('reset');
                    } else {
                        this.pause(false)
                    }
                    this.stepBtn.disabled = file_data.stepBtn ?? false;
                    this.buildGIF.disabled = file_data.buildGIF ?? false;
                    this.RunPauseBtn.disabled = file_data.RunPauseBtn ?? false;

                    this.updateUI();
                    this.updateResults();
                    return true;
                }

                reset() {
                    try {
                        clearTimeout(this.auto_run_timeout);
                        const rules = window.getRulesText(); // Using the Ace Editor content
                        this.gifCard.style.display = "none";
                        this.gifContainer.style.display = 'none';
                        this.GIFStatus.textContent = "No GIF Created yet"
                        const transitions = new TuringConfig().parseTransitionRules(rules);
                        this.initial_tape = this.tapeInput.value;
                        this.init_time = TuringConfig.getTimestamp();
                        this.cpu = new MachineLogic(transitions);
                        this.cpu._setTape(this.initial_tape);

                        this.max_len = 0;
                        this.tape_len = 0;
                        this.step_count = 0;
                        this.running = false;
                        this.buildGIF.disabled = true;
                        this.stepBtn.disabled = false;
                        this.ControlBtn.disabled = false;
                        this.RunPauseBtn.disabled = false;
                        this.updateControlButton('run');
                        this.updateMachineStatus(`Model '${this.modelName}' Loaded`, "text-secondary");
                        this.rulesNo = this.cpu.transitions_list.length
                        this.history = [{
                            tape: { ...this.cpu.tape },
                            head: this.cpu.head_position,
                            state: this.cpu.current_state,
                            move: "N",
                        }];

                        // Update UI & results
                        this.updateUI();
                        this.updateResults();

                    } catch (error) {
                        console.error("Load error:", error);
                        this.updateMachineStatus(error, "text-danger");
                        alert(`Error during load: ${error.message}`);
                    }
                }

                step(printStep = true) {
                    try {
                        const steps_to_run = parseInt(this.stepEntry.value) || this.BASE_STEP;
                        const max_allowed = parseInt(this.maxSteps.value) || this.MAX_STEPS;
                        this.buildGIF.disabled = false;
                        if (printStep) {
                            this.updateMachineStatus(`Machine ran for ${steps_to_run} steps`, "text-primary");              // When started
                        }
                        for (let i = 0; i < steps_to_run; i++) {
                            if (this.step_count >= max_allowed) {
                                this.updateMachineStatus(`Max steps (${max_allowed}) reached`, "text-danger");
                                this.pause(false);
                                break;
                            }

                            if (this.cpu.current_state === this.cpu.halt_state) {
                                this.HALT();
                                break;
                            }

                            try {
                                this.cpu._stepLogic();
                                this.step_count++;
                                this.history[this.step_count -1]['move'] = this.cpu.headMove;
                                this.tape_len = Object.keys(this.cpu.tape).length;
                                this.max_len = Math.max(this.max_len, this.tape_len);
                                this.history.push({
                                    tape: { ...this.cpu.tape },
                                    head: this.cpu.head_position,
                                    state: this.cpu.current_state,
                                    move: "N",
                                    tape_len: this.tape_len,
                                });

                                // Update UI & results
                                this.updateUI();
                                this.updateResults();
                            } catch (error) {
                                const textContent = `Machine STUCK | After ${this.step_count} steps`;
                                this.updateMachineStatus(textContent, "text-danger");
                                this.pause(false);
                                throw error;
                            }
                        }
                    } catch (error) {
                        console.error("Step error:", error);
                        this.updateMachineStatus(error, "text-danger");
                        alert(`Error during step: ${error.message}`);
                    }
                }

                pause(printPause = true) {
                    if (printPause) {
                        this.updateMachineStatus(`Machine Paused after ${this.step_count} steps`, "text-warning");
                    }
                    this.running = false;
                    clearTimeout(this.auto_run_timeout);
                    this.updateControlButton('run');
                    this.stepBtn.disabled = false;
                }

                HALT() {
                    this.running = false;
                    this.stepBtn.disabled = true;
                    this.RunPauseBtn.disabled = true
                    this.buildGIF.disabled = false;

                    this.updateControlButton('reset');
                    const textContent = `Machine HALTED | Total Steps: ${this.step_count}`;
                    this.updateMachineStatus(textContent, "text-success");    // On halt
                }

                run() {
                    this.running = true;
                    this.stepBtn.disabled = true;

                    this.updateControlButton('pause');
                    this.autoStep();
                }

                autoStep() {
                    if (!this.running) return;
                    if (this.cpu.current_state === this.cpu.halt_state) {
                        this.HALT();
                        return;
                    }
                    this.updateMachineStatus("Machine AutoRun", "text-primary");              // When started

                    this.step(false);

                    const delay = parseInt(this.delayEntry.value) || this.DELAY;
                    this.auto_run_timeout = setTimeout(() => this.autoStep(), delay);
                }

                seekHistory(step) {
                    step = parseInt(step);
                    if (isNaN(step)) return;

                    if (step < 0 || step >= this.history.length) {
                        return;
                    }

                    const snapshot = this.history[step];
                    this.cpu.tape = { ...snapshot.tape };
                    this.cpu.head_position = snapshot.head;
                    this.cpu.current_state = snapshot.state;
                    this.step_count = step;
                    this.updateUI();
                }

                goToStep() {
                    const step = parseInt(this.gotoStep.value);
                    if (isNaN(step)) {
                        alert("Please enter a valid step number");
                        return;
                    }

                    if (step < 0 || step > this.history.length - 1) {
                        alert(`Step must be between 0 and ${this.history.length - 1}`);
                        return;
                    }

                    this.historySlider.value = step;
                    this.seekHistory(step);
                }

                setAllButtonsDisabled(disabled) {
                    document.querySelectorAll('button:not(#cancelGIF)').forEach(btn => {
                        btn.disabled = disabled;
                    });
                }

                updateUI() {
                    // Update tape display
                    this.tapeDisplay.innerHTML = "";

                    const positions = Object.keys(this.cpu.tape).map(Number);
                    const min_pos = positions.length > 0 ? Math.min(...positions) : 0;
                    const max_pos = positions.length > 0 ? Math.max(...positions) : 0;

                    // Show at least 5 cells before and after the head position
                    const start_pos = Math.min(min_pos, this.cpu.head_position) - 7;
                    const end_pos = Math.max(max_pos, this.cpu.head_position) + 7;

                    for (let pos = start_pos; pos <= end_pos; pos++) {
                        const cell = document.createElement('div');
                        cell.className = 'tape-cell';
                        cell.textContent = this.cpu.tape[pos] !== undefined ? this.cpu.tape[pos] : this.cpu.blank_symbol;
                        if (pos === this.cpu.head_position) {
                            cell.classList.add('active');
                        }
                        this.tapeDisplay.appendChild(cell);
                    }
                    // Scroll the active cell horizontally without affecting vertical position
                    const activeCell = this.tapeDisplay.querySelector('.active');
                    if (activeCell) {
                        activeCell.scrollIntoView({
                            behavior: 'auto',
                            block: 'nearest',  // This prevents vertical scrolling
                            inline: 'center'   // This handles horizontal scrolling
                        });
                    }

                    // Restore vertical scroll position
                    window.scrollTo(0, scrollY);

                    // Update status
                    this.historySlider.max = this.history.length - 1;
                    this.historySlider.value = this.step_count;
                    this.gotoStep.value = this.step_count;

                    // Update step state display
                    this.updateStepState();

                }

                updateResults() {
                    this.cpu.stepCount = this.step_count;
                    const final_tape = this.cpu._printTapeState();
                    const resources_used = [
                        `    Time run: ${(TuringConfig.getTimestamp() - this.init_time).toFixed(5)}s`,
                        ` Memory used: ${TuringConfig.getCurrentMemoryMB()}MB`
                    ];

                    const results = [
                        `   Tape Size: Max = ${this.max_len} | Now = ${this.tape_len} `,
                        `Initial Tape: '${this.initial_tape}'`,
                        ` Result Tape: '${final_tape}'`,
                        ` Steps Count: ${this.step_count}`,
                        ` Total Rules: ${this.rulesNo}`,
                        ...resources_used
                    ];

                    this.results.innerHTML = results.join('<br>');
                }

                updateStepState() {
                    const step = parseInt(this.historySlider.value);
                    const prev = step > 0 ? this.history[step - 1].state : "--";
                    const curr = this.history[step].state;
                    const next = step + 1 < this.history.length ? this.history[step + 1].state : 
                        (step === this.step_count ? "--" : "--");
                    this.stepState.innerHTML = ` Step [${step}]: ${prev} <- <span class="tape-current">${curr}</span> -> ${next}`;
                }

                updateControlButton(state) {
                    const btn_ctrl = this.ControlBtn;
                    btn_ctrl.className = 'control-btn'; // Reset classes

                    const btn_rp = this.RunPauseBtn;
                    btn_rp.className = 'btn w-100 action-btn';

                    switch(state) {
                        case 'run':
                            btn_ctrl.classList.add('btn-run');
                            btn_rp.classList.add('btn-run');
                            btn_ctrl.innerHTML = '<i class="bi bi-play-fill"></i>';
                            btn_rp.innerHTML = '<i class="w-100 bi bi-play-fill"></i>Play';
                            break;
                        case 'pause':
                            btn_ctrl.classList.add('btn-pause');
                            btn_rp.classList.add('btn-pause');
                            btn_ctrl.innerHTML = '<i class="bi bi-pause-fill"></i>';
                            btn_rp.innerHTML = '<i class="w-100 bi bi-pause-fill"></i>Stop';
                            break;
                        case 'reset':
                            btn_ctrl.classList.add('btn-reset');
                            btn_rp.classList.add('btn-run');
                            btn_ctrl.innerHTML = '<i class="bi bi-arrow-clockwise"></i>';
                            btn_rp.innerHTML = '<i class="w-100 bi bi-play-fill"></i>Play';
                            break;
                    }
                }

                updateMachineStatus(text, colorClass = "text-primary") {
                    const statusEl = this.machineStatus;
                    statusEl.className = `machineStatus fw-bold text-center ${colorClass}`;
                    statusEl.textContent = text;
                }

                async generateGIFFromHistory() {
                    try {
                        this.gifContainer.style.display = 'none';
                        this.setAllButtonsDisabled(true);

                        // Initialize GIFBuilder
                        this.gifBuilder = new GIFBuilder(
                            this.tapeDisplay, this.GIFStatus,
                            this.modelName, this.rulesNo, this.max_len,
                        );

                        // Generate GIF
                        const blob = await this.gifBuilder.buildFromHistory(
                            this.history, (step) => this.seekHistory(step)
                        );

                    } catch (error) {
                        console.error("GIF generation error:", error);
                        this.gifProgress.textContent = `Error: ${error.message}`;
                    } finally {
                        this.setAllButtonsDisabled(false);
                    }
                }

                handleExports() {
                    const previewElement = document.getElementById("exportPreview");
                    const exportFormatRadios = document.querySelectorAll('input[name="exportFormat"]');
                    const exportClose = document.getElementById('closeExport');
                    let file_data = "";
                    let selectedFormat = "";

                    // --- Update preview when format changes ---
                    exportFormatRadios.forEach(radio => {
                        radio.addEventListener("change", () => {
                            selectedFormat = document.querySelector('input[name="exportFormat"]:checked').value;
                            file_data = this.stateManager.exportFileData(selectedFormat);
                            previewElement.value = file_data;
                        });
                    });

                    // --- Download current preview on Save click ---
                    this.saveBtn.addEventListener("click", () => {
                        this.stateManager.downloadFile(file_data, selectedFormat);
                    });

                    // Close buttons and clear exsting selections
                    exportClose.addEventListener("click", () => {
                        exportFormatRadios.forEach(radio => {radio.checked = false;});
                        previewElement.value = ""
                    });
                }

            }

            // Expose core modules globally
            window.TuringConfig = TuringConfig;
            window.MachineLogic = MachineLogic;
            window.Simulator_GUI = Simulator_GUI;

            // ===== ACE EDITOR INITIALIZATION =====
            const editor = ace.edit("rulesEditor");
            editor.setTheme("ace/theme/KatzenMilch");
            editor.session.setMode("ace/mode/text");
            editor.setOptions({
                fontSize: "13px",
                showLineNumbers: true,
                showGutter: true,
                cursorStyle: "ace",
                highlightActiveLine: true,
                enableBasicAutocompletion: true,
                enableLiveAutocompletion: true
            });

            window.getRulesText = () => editor.getValue();
            window.setRulesText = (text) => editor.setValue(text);

            // ===== SIMULATOR INITIALIZATION =====
            let simulator = new Simulator_GUI();
            simulator.loadExample("unary_increment")

            window.applyConfig = function () {
                const confirmed = confirm("Are you sure you want to completely re-configure the Turing Simulator?");
                if (!confirmed) return;

                TuringConfig.updateFromInputs();

                // Remove all old event listeners from key elements by cloning
                simulator.delElements()
                if (window.simulator && typeof simulator.destroy === "function") {
                    simulator.destroy();
                }

                // Now create new simulator
                simulator = new Simulator_GUI();
                simulator.modelName = simulator.modelInputName.value.trim();
                simulator.reset()
            };

        </script>

        <!-- Footer -->
        <footer class="text-center py-2 mt-5 bg-light border-top small text-muted">
            <div class="container">
                <div class="mb-2">
                    &copy; <span id="year"></span> Abbas Moosajee &nbsp;|&nbsp;
                    <a href="https://github.com/abbasmoosajee07/TuringMachineSim" target="_blank" title="View on GitHub" class="text-dark text-decoration-none">
                        <i class="bi bi-github align-middle"></i> GitHub
                    </a>
                    &nbsp;|&nbsp; MIT License
                </div>
            </div>
        </footer>

    </body>

</html>
